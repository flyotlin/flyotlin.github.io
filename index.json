[{"content":"劇情簡介 某個虛構世界中某天突然出現了可以連結現實世界與異次元空間的傳送門，傳送門中充斥著各種魔獸。 為了避免7天後封印解除，獵人們需要進入傳送門將魔獸清除。 獵人分為S級、A-E級，主角振宇是最低的E級獵人。某次D級討伐任務中遇到雙重地下城，差點全員命喪第二座神殿地下城。 地下城的三條戒律是崇拜神、讚美神，以及證明你的信仰。 主角振宇戰鬥能力非常弱，每次都是討伐任務的拖油瓶，不過他的腦袋十分靈光。在神殿中成功靠著機智存活下來。\n心得 這部動畫是韓國原著漫畫與日本的A1-Pictures 合作改編而成的。起初對於韓國漫畫改編挺有興趣的，在這之前只知道webtoon，因此想了解現在韓國漫畫產業發展的狀況。另外，也是因為我近期十分喜愛的podcast曼報推薦，雙重誘因之下才開始看這部動畫。 動畫的人物每個都畫的很精緻偏美型，這也許是韓漫的特色。 動畫的日配唸出角色的韓文名字有點難記，也有種莫名好笑、奇怪的違和感。 最吸引我繼續看下去的是，動畫的張力感十足，前兩三集振宇在討伐任務中出生入死，觀看過程中心也跟著揪著，真的十分刺激，看完之後都會期待下一集的發展。 該噴番茄醬、發便當的地方也毫不手軟，有種比日漫更加黑暗的感覺。 另一方面，主角的初始能力設定非常普通，在觀看過程中十分能將自己投射到主角上。因為主角就像是我們，一個什麼特殊能力都沒有的普通人。\n","permalink":"https://flyotlin.github.io/posts/%E6%88%91%E7%8D%A8%E8%87%AA%E5%8D%87%E7%B4%9A/","summary":"\u003ch2 id=\"劇情簡介\"\u003e劇情簡介\u003c/h2\u003e\n\u003cp\u003e某個虛構世界中某天突然出現了可以連結現實世界與異次元空間的傳送門，傳送門中充斥著各種魔獸。\n為了避免7天後封印解除，獵人們需要進入傳送門將魔獸清除。\n獵人分為S級、A-E級，主角振宇是最低的E級獵人。某次D級討伐任務中遇到雙重地下城，差點全員命喪第二座神殿地下城。\n地下城的三條戒律是崇拜神、讚美神，以及證明你的信仰。\n主角振宇戰鬥能力非常弱，每次都是討伐任務的拖油瓶，不過他的腦袋十分靈光。在神殿中成功靠著機智存活下來。\u003c/p\u003e","title":"我獨自升級"},{"content":"會想要看這部主因是新竹城隍廟附近的二輪戲院（新復珍戲院）最近上映的電影中，這部是我比較有興趣的。除了以天主教、梵蒂岡、驅魔為題材外，主演教廷驅魔士的羅素克洛也是吸引我的其中一點。\n題外話，當天最後一場電影票特價只要 110 元，爆米花 45 元，搭配飲料 65 元，算是滿經濟實惠的選擇，影廳內人不是太多，空間及座椅也十分舒適。螢幕大小、聲光效果也滿不錯的，本片剛好有一幕能體驗到影廳的環繞音效，音響體驗十分優良。唯一小缺點是當天去的時候，影廳內冷氣似乎不是很涼。\n劇情從介紹羅素克洛主演的驅魔士主角開始，安排了橋段讓主角小試身手，把惡魔轉移到黑豬上驅魔成功。老實說，看完電影後回想起這段，除了介紹外還真不知道安排這段的用意是什麼。接著鏡頭轉到西班牙的古老修道院，從美國來的 emily 一家打算整修過世父親的遺產，脫手後轉賣一筆。惡運就此而來，兒子 henry 被強大的邪靈附身，只得從羅馬請來教廷首席驅魔士來對抗惡魔。\n了解邪靈後，進行了各種驅魔儀式，emily 一家人以及主角、助手受到邪靈的各種惡搞、折磨、逼迫，就連遠在羅馬的教宗也受到強大邪靈的影響而導致病情加重。同時間，主角也發現了邪靈的計謀，找出了地底下中古世紀迫害異教徒的遺址，並且得知原來邪靈的目標是自己，過去邪靈也曾附身在一名驅魔士上，還有日記寫下了邪靈的名字。\n這樣好辦了，開始唸禱告文、信仰信念加 100、念出邪靈的名字，最後最重要的再用聖物進行物理驅魔，成功。片尾提到了還剩下 199 名邪靈，似乎在替續集埋伏筆。\n之前沒看過什麼驅魔片，有印象的是 2019 年韓國拍的「驅魔使者」，不過印象中是部爛片。這部片我覺得算滿好看的，或許當作動作+搞笑片，不要抱持著驅魔、驚悚片的期待去看比較不會失望。羅素克洛的搞笑以及不時脫口的笑話滿大程度緩和了劇情發展，這也是我以搞笑片角度觀賞本片的原因。\n我對基督、天主信仰與文化並不是這麼熟悉，片中帶出的修道院、教堂、教廷場景，驅魔士、神父口中的祝禱詞，劇情設定的200個墮入凡間的邪靈，有讓我想更深入了解奠定西方文化基礎的如此重要的信仰。片中告解的橋段我自己也覺得十分有趣，雖然之前就知道這項儀式，但看到實際在生活中對信仰者的意義及進行方式，還是頗新奇。整部片雖然以驅魔、天主教為題材，宗教意味並不濃厚，但驅魔成功是靠信仰、信任、愛，似乎是基督、天主宗教中的關鍵基礎。另外，或許是隨時間才逐步演變為此，基督、天主教對電影潮流文化向傳統文化的刺激與挑戰的包容，換作是佛教、伊斯蘭教的話，或許還無法接受這樣的衝擊吧。\n","permalink":"https://flyotlin.github.io/posts/%E6%A2%B5%E8%92%82%E5%B2%A1%E9%A9%85%E9%AD%94%E5%A3%AB/","summary":"\u003cp\u003e會想要看這部主因是新竹城隍廟附近的二輪戲院（新復珍戲院）最近上映的電影中，這部是我比較有興趣的。除了以天主教、梵蒂岡、驅魔為題材外，主演教廷驅魔士的羅素克洛也是吸引我的其中一點。\u003c/p\u003e","title":"梵蒂岡驅魔士"},{"content":"bash script 前面沒有特別設定的話，執行時遇到錯誤，通常會繼續往下執行，而不會像平常熟悉的程式語言遇到 exception 時（沒有 error handling）直接跳出結束執行。\n另外，在開發、撰寫 bash script 時，也時常有需要 debug 的時候。\n因此，以下簡單介紹一些常用且有幫助的 bash script 前置設定。\n以下設定只在 bash 上測試過，其他 shell 不一定能使用。\nset -x 在 bash script 開發過程中，如果需要 debug 可以在 script 前面加上 set -x。行為是 script 在執行時，執行每一行指令前，會先把指令印出來。\n雖然不像一些高階程式語言有 debugger 能設中斷點、直接觀察變數值以及 stack 狀況，但對於有許多變數、迴圈、邏輯判斷的複雜 script 來說，透過 print-debug like 的方式來找碴也十分有幫助。\nset -eou pipefail bash script 執行時遇到錯誤，以及遇到 unset variable 時，預設不會中斷而是會繼續執行。面對這種狀況，能在 script 前加上 set -eou pipefail 解決以上問題。\nArguments -e: 任何指令執行失敗會讓整個script跳出，return value非零。\n-u: unset variables would exit the script.\n-o pipefail: pipeline會把最後一個指令當作return value。\n使用此option後只要pipeline中任一指令失敗就會回傳非零。\n不過，要搭配-e才能避免失敗後繼續往下執行。\nTest -e:\n#!/bin/bash set -e # 請自行移除觀察行為有何差別 ls not-exist echo \u0026#34;HI\u0026#34; 加上 set -e 後就不會印出 HI，另外，echo $? 觀察 return value 也從 0 變成 1\n-u:\n#!/bin/bash set -u # 請自行移除觀察行為有何差別 echo \u0026#34;$notset\u0026#34; 加上 set -u 後第 5 行會報錯，另外，echo $? 觀察 return value 也從 0 變成 1\n-o pipefail\n#!/bin/bash set -o pipefail # 請自行移除觀察行為有何差別 ls not-exist | echo \u0026#34;HI\u0026#34; 加上 set -o pipefail 後 依然會繼續執行 pipeline 剩餘指令，因此能看到 stdout 印出 HI。\n原本 script 會把 pipeline 最後一個指令的 return 當作 return value，但加上此 option 後，只要 pipeline 中任何一個指令失敗，return\nvalue 就是 1，因此觀察到 return value 從 0 變成 1。\n#!/bin/bash set -o pipefail # 請自行移除觀察行為有何差別 echo \u0026#34;HI\u0026#34; | ls not-exist 這個範例無論有沒有加 set -o pipefail，return value 都是 1，原因與上面提到 pipeline 的 return value 機制有關。\n範例 Example sciprt #!/bin/bash set -eou pipefail set -x # your script... 結語 之後有遇到其他好用的設定會再慢慢更新上來\u0026hellip;\n","permalink":"https://flyotlin.github.io/posts/bash-script-shell-script-%E7%9A%84%E5%A5%BD%E7%BF%92%E6%85%A3/","summary":"\u003cp\u003ebash script 前面沒有特別設定的話，執行時遇到錯誤，通常會繼續往下執行，而不會像平常熟悉的程式語言遇到 exception 時（沒有 error handling）直接跳出結束執行。\u003c/p\u003e\n\u003cp\u003e另外，在開發、撰寫 bash script 時，也時常有需要 debug 的時候。\u003c/p\u003e","title":"Bash Script 的好習慣"},{"content":"從大一到大三，一直都很好奇宿舍網路的註冊及運作機制。但每次開通成功後，想要繼續深究的動力就直接消失。\n這次剛好在註冊、開通的過程遇到了些問題，就順手分享除錯過程，以及我對整個宿網運作機制的猜測及理解。\n沒辦法連上網路 起初對這個問題，做了幾個可能發生的假設。\nMAC address 填錯 Port number (A, B, C, D) 填錯 第 1 點是不可能的，畢竟從大一就用到現在。第 2 點在詢問後，也發現其實 port number 一點都不重要 ==。\n就在萬念俱灰之際，剛好逛到分享器設定頁面，發現外網 ip 怎麼不是 140.115.xxx.xxx！\n原本的假設是將分享器設定自動取得 IP (DHCP) 後，應該就會自動把 IP 設定為 140.115.xxx.xxx。但事與願違，只好手動觸發自動 IP 設定精靈，才解決了連線的問題。\nDHCP 在講宿網怎麼運作前，先來聊聊 DHCP。在古老的時代，終端設備要連上網路都只能透過手動設定 IP, Netmask, Gateway, DNS。\n於是就誕生了 DHCP，只要連上網路，就會自動設定 IP。\n連上網路的終端設備 (電腦) 會向整個網路發出 DHCP request 的廣播封包，裡面會包含設備的 MAC address。\n接著網路上的 DHCP server 收到這個封包，自動分配一個可用的 IP，並且將 IP 及相關的 netmask, gateway, DNS 夾帶在 DHCP response 封包中。\n最後，當設備收到 response 封包後，就能根據封包中資訊，正確設定網路的連線資訊。\nDHCP server 除了隨機自動分配可用 IP 外，也能夠幫特定設備 (以 MAC address 辨識) 保留一組 IP，MAC address 與 IP 的 mapping 則會記錄在 DHCP server 上的 reservation list。\n詳細還有關於 reservation list lease (租約) 過期的問題，推薦參考：\nDHCP Explained - Dynamic Host Configuration Protocol 動態主機設定協定 宿網的註冊 以下都是我的自行推論，有可能實際上並不是這麼運作。\n當你購買宿網授權，並且正確填入 MAC address 後，系統會分配一個 140.115.xxx.xxx 給你。\n同時，也會在校內網路 DHCP server 的 reservation list 紀錄分配的 140.115.xxx.xxx 要對應到你填的 MAC address。\n你的設備連上宿網後，會在校內網路發送 DHCP 的 request 廣播封包。被 DHCP server 收到後，根據 reservation list 的資訊，把你分配到的 IP 140.115.xxx.xxx 回傳給你。你的設備就能透過 DHCP response 的資訊正確上網了。\n宿網的阻擋機制 那宿網是怎麼阻擋沒有註冊的人使用網路呢？我的猜測是藉由 reservation list 中 IP 與 MAC address 的對應。\n當你要連到外部網路時，request 封包會通過校內網路的 gateway。學校計中或許在 gateway 的防火牆設置了 MAC address filter，過濾掉 IP 跟 MAC address 對應不起來的封包，進而實現了阻擋沒購買的人使用宿網。\n結語 我猜只要能夠偽造某個 IP 註冊的 MAC address，應該就能免費使用宿網了！\n但\u0026hellip; 恩，當我沒說 XD\n","permalink":"https://flyotlin.github.io/posts/%E9%97%9C%E6%96%BC%E4%B8%AD%E5%A4%AE%E5%AE%BF%E7%B6%B2%E7%9A%84%E9%80%99%E6%AA%94%E4%BA%8B/","summary":"\u003cp\u003e從大一到大三，一直都很好奇宿舍網路的註冊及運作機制。但每次開通成功後，想要繼續深究的動力就直接消失。\u003c/p\u003e\n\u003cp\u003e這次剛好在註冊、開通的過程遇到了些問題，就順手分享除錯過程，以及我對整個宿網運作機制的猜測及理解。\u003c/p\u003e","title":"關於中央宿網的這檔事"},{"content":"校內工讀的伺服器上部署了 3-4 個不同的網站，好在當初有使用 PHP 的容器化解決方案 - Laradock，能夠以容器化的方式使用多個服務。\n這次遇到的問題是 MySQL 對 arm64 (M1 Mac) 的支援度並不好，再加上沒有將前一次 Laradock 啟動後產生的 MySQL 檔案清乾淨，導致 local 啟動時踩了不少坑。\n接下來會直接簡述如何確保 M1 Mac 能順利啟動包含 MySQL 服務的 Laradock，最後才是 tedious 的 debug 過程。\nHow to Run Laradock with MySQL on M1 Mac Laradock .env 中的 MYSQL_VERSION 要指定為 arm64 版本的 image，如 8.0.29-oracle。 確保 ~/.laradock/data/ 中沒有 mysql 資料夾，否則會有存取問題。 MySQL support for ARM 一開始 Laradock build nginx, MySQL 時就會出現錯誤，原因是 MySQL latest image 並不支援 arm64 平台。\n稍微 google 後，許多 2021 年初的文章推薦直接在 pull image 時指定 platform 為 linux/x86_64。\n也發現其實 MySQL 開始支援 arm 平台，但需要另外指定對應的 tag。\n目前以 MySQL 8.0 以上帶有 oracle 後綴的 tag 為主。\nWeird MySQL Errors Google 了一下並經過思考後，我決定使用 arm64 版本的 MySQL image。但這也是一連串奇怪錯誤的開始\u0026hellip;\nFailed to Run MySQL 第一個是比較容易理解的錯誤，由於 Laradock 中的 MySQL 沒有順利啟動，其他依賴資料庫的 web 服務 (laradock) 當然也沒好受。\n最直接的錯誤是：\nphp_network_getaddresses: getaddrinfo failed: Temporary failure in name resolution\n很明顯問題是 MySQL 啟動失敗，web 服務沒辦法存取 MySQL。\n會出現 name resolution 錯誤是因為 Laradock 各個服務透過 docker-compose 啟動，彼此透過 service 名稱連線。\nMySQL 沒啟動，當然沒辦法將 MySQL service name (mysql) 解析成該容器對應的 private ip。\nLaradock 的大坑 發現是 MySQL 的錯誤後，緊接著檢查了 container logs 的錯誤訊息，分別發現了 2 個奇怪的錯誤。\nLinux Native AIO interface is not supported on this platform\nchown: cannot read directory '/var/lib/mysql/': Permission denied\n找了半天，在 docker-compose.yml 中看到了蛛絲馬跡。\n// from .env DATA_PATH_HOST=~/.laradock/data // from docker-compose.yml mysql: build: context: ./mysql args: - MYSQL_VERSION=${MYSQL_VERSION} environment: - MYSQL_DATABASE=${MYSQL_DATABASE} - MYSQL_USER=${MYSQL_USER} - MYSQL_PASSWORD=${MYSQL_PASSWORD} - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} - TZ=${WORKSPACE_TIMEZONE} volumes: - ${DATA_PATH_HOST}/mysql:/var/lib/mysql // 元兇！ - ${MYSQL_ENTRYPOINT_INITDB}:/docker-entrypoint-initdb.d ports: - \u0026#34;${MYSQL_PORT}:3306\u0026#34; networks: - backend 原來 Laradock build MySQL 時會把 MySQL 相關設定 mount 到 ~/.laradock/data/mysql，進而導致後續一連串的奇怪問題。\n","permalink":"https://flyotlin.github.io/posts/%E5%9C%A8-m1-mac-%E4%B8%8A%E5%95%9F%E5%8B%95-php-laradock/","summary":"\u003cp\u003e校內工讀的伺服器上部署了 3-4 個不同的網站，好在當初有使用 PHP 的容器化解決方案 - Laradock，能夠以容器化的方式使用多個服務。\u003c/p\u003e\n\u003cp\u003e這次遇到的問題是 MySQL 對 arm64 (M1 Mac) 的支援度並不好，再加上沒有將前一次 Laradock 啟動後產生的 MySQL 檔案清乾淨，導致 local 啟動時踩了不少坑。\u003c/p\u003e","title":"在 M1 Mac 上啟動 PHP Laradock"},{"content":"解題想法 這題用的演算法主要是dijkstra，求權重圖的最短路徑，但不能有負邊。\n由於題目給的是到終點時的貨物數量，要我們求起點出發要有多少貨物。 所以在這邊我們選擇從終點反向計算到各點的single-source shortest path。最後輸出終點到起點的shortest path。\n這題邊的權重可以看做是過路費，進到鄉村只收1單位貨物，進到城市則是每20個貨物收1單位貨物的過路費。\n因此dijkstra在進行relaxation的時候，要看該點權重加上進入該點的過路費，有沒有小於下個點權重，小於的話就更新下個點的shortest path。 上圖由A點更新其他點，更新後各點的狀況。\n另外，題目還需要輸出經過的地方。這個只需要用一個陣列pre[]來記錄他的上個點是誰即可。\n參考 我在學dijkstra的時候，看的是這位印度帥哥的教學影片。大推! Dijkstra - Abdul Bari\n程式碼 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; // 將abc轉為0~51的編碼 int decode(char x) { if (x \u0026gt;= 65 \u0026amp;\u0026amp; x \u0026lt;= 90) return x-65; if (x \u0026gt;= 97 \u0026amp;\u0026amp; x \u0026lt;= 122) return x-71; return 0; } // 將0~51的編碼轉回abc int encode(int x) { if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt;= 25) return x + 65; if (x \u0026gt;= 26 \u0026amp;\u0026amp; x \u0026lt;= 51) return x + 71; return 0; } long long INF = 0x7fffffffffff; // 無限大 int cases = 1; // 紀錄目前為第幾個case int main() { int path_num; char a, b, s, e; int aa, bb, start, end, item_num; while (cin \u0026gt;\u0026gt; path_num \u0026amp;\u0026amp; path_num != -1) { vector\u0026lt;int\u0026gt; map[60]; for (int i = 0; i \u0026lt; path_num; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; aa = decode(a); bb = decode(b); // 建圖 map[aa].push_back(bb); map[bb].push_back(aa); } cin \u0026gt;\u0026gt; item_num \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e; // 輸入題目問題 start = decode(s); end = decode(e); // 由end開始進行反向dijkstra int pre[60]; // 該點的前一個點 bool visit[60]; // 是否造訪過 long long d[60]; // 該點的最短路徑值 // 初始化 for (int i = 0; i \u0026lt; 60; i++) { pre[i] = -1; visit[i] = false; d[i] = INF; } queue\u0026lt;int\u0026gt; q; q.push(end); visit[end] = true; d[end] = item_num; int front, current, smaller_no; long long toll, smaller; while (!q.empty()) { front = q.front(); q.pop(); // 計算過路費 if (front \u0026gt;= 0 \u0026amp;\u0026amp; front \u0026lt;= 25) // 城市 toll = ceil(d[front] * 20.0 / 19.0); else // 鄉村 toll = d[front] + 1; // 進行dijkstra relaxation for (int i = 0; i \u0026lt; map[front].size(); i++) { current = map[front][i]; if (toll \u0026lt; d[current]) { d[current] = toll; pre[current] = front; } } // 挑選目前圖中，未造訪且權重最小的點 smaller = INF; for (int i = 0; i \u0026lt; 52; i++) if (visit[i] == false \u0026amp;\u0026amp; d[i] \u0026lt; smaller) { smaller = d[i]; smaller_no = i; } // 將點放到queue裡面 if (smaller \u0026lt; INF) { q.push(smaller_no); visit[smaller_no] = true; } } // 輸出答案 cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; cases++ \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; d[start] \u0026lt;\u0026lt; endl; current = start; while (current != end) { cout \u0026lt;\u0026lt; (char)encode(current) \u0026lt;\u0026lt; \u0026#34;-\u0026#34;; current = pre[current]; } cout \u0026lt;\u0026lt; (char)encode(current) \u0026lt;\u0026lt; endl; } return 0; } ","permalink":"https://flyotlin.github.io/posts/10537---the-toll-revisited/","summary":"\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003cp\u003e這題用的演算法主要是dijkstra，求權重圖的最短路徑，但不能有負邊。\u003c/p\u003e\n\u003cp\u003e由於題目給的是到終點時的貨物數量，要我們求起點出發要有多少貨物。\n所以在這邊我們選擇從終點反向計算到各點的single-source shortest path。最後輸出終點到起點的shortest path。\u003c/p\u003e","title":"10537 - The Toll! Revisited"},{"content":"題目敘述 這題輸入滿複雜的，分為三個部分，會先輸入有幾組測資。\nPART 1: 城市名稱 PART 2: 列車資訊 PART 3: 出發時間 出發城市 抵達城市 解題想法 這題第一眼看到以為是dfs+圖論，但後來看了別人的解法後才發現是dp。\ndp式子: dp[抵達時間][抵達城市] = 最晚出發時間\n初始設定:\n將整個dp array(最晚出發時間)設為-1，不能設為0(因為0代表00:00) 出發城市所有能到達的城市(k)，給定dp[抵達時間][k]的初始值。 轉移條件: dp[i][j] = max(dp[i][j], 到城市的最晚出發時間)\n解釋 G[startNum][i].startTime \u0026gt;= journey_startTime\n要能從出發城市(s)到下個城市(i)的話，就是上面的式子，\n條件為列車從s出發的時間比題目給的開始旅行時間晚。\nmax(dp[G[startNum][i].endTime][G[startNum][i].cityNo], G[startNum][i].startTime)\nG[startNum][i]: 為出發城市能到達的城市的節點 startTime: 列車出發的時間 endTime: 抵達該城市的時間 cityNo: 該抵達城市的編號 前面為原本的，後面是新的出發時間，兩者取較晚的。\nG[j][k].startTime \u0026gt;= i\nG[j][k].startTime 是到城市k的出發時間 i 是抵達城市j的時間 接著看看第四點\nmax(dp[G[j][k].endTime][G[j][k].cityNo], dp[i][j])\n前者是原本的，後者為什麼是dp[i][j]，以及為什麼第三點的條件式這樣呢?\n請看看下面這張圖\n所以dp[i][j]就是在某城市出發的時間，接著先到J，最後再到k。\n而要確保乘客能搭到這班車，條件就是由J往k的出發時間比i還晚，也就是第三點的條件。\n參考: Morris\n程式碼 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct edge { int cityNo, startTime, endTime; edge(int a, int b, int c): cityNo{a}, startTime{b}, endTime{c} {} }; vector\u0026lt;edge\u0026gt; G[105]; // 最多100個城市 int dp[2400][105]; // 抵達時間/城市編號 int main() { int test_cases, cases = 1; cin \u0026gt;\u0026gt; test_cases; int city_num; map\u0026lt;string, int\u0026gt; city_map; string tmp; while (test_cases--) { cin \u0026gt;\u0026gt; city_num; for (int i = 0; i \u0026lt; city_num; i++) { cin \u0026gt;\u0026gt; tmp; city_map[tmp] = i; G[i].clear(); } int train_num; cin \u0026gt;\u0026gt; train_num; for (int i = 0; i \u0026lt; train_num; i++) { int stop_num; cin \u0026gt;\u0026gt; stop_num; int time; // 輸入時的 時間 string station; // 輸入時的 車站 int prev_time; // 上次的 時間 string prev_station;// 上次的 車站 for (int j = 0; j \u0026lt; stop_num; j++) { cin \u0026gt;\u0026gt; time \u0026gt;\u0026gt; station; if (j != 0) G[city_map[prev_station]].push_back(edge(city_map[station], prev_time, time)); prev_station = station; prev_time = time; } } int journey_startTime; string startCity, endCity; cin \u0026gt;\u0026gt; journey_startTime \u0026gt;\u0026gt; startCity \u0026gt;\u0026gt; endCity; int startNum = city_map[startCity]; int endNum = city_map[endCity]; // Solve cout \u0026lt;\u0026lt; \u0026#34;Scenario \u0026#34; \u0026lt;\u0026lt; cases++ \u0026lt;\u0026lt; endl; // // 初始dp for (int i = 0; i \u0026lt; 2400; i++) for (int j = 0; j \u0026lt; 105; j++) dp[i][j] = -1; // 初始最晚出發時間為-1，0代表00:00(所以不能用) // 初始出發城市的dp狀態 for (int i = 0; i \u0026lt; G[startNum].size(); i++) { // G[startNum][i] if (G[startNum][i].startTime \u0026gt;= journey_startTime) dp[G[startNum][i].endTime][G[startNum][i].cityNo] = max(dp[G[startNum][i].endTime][G[startNum][i].cityNo], G[startNum][i].startTime); } bool has_solution = false; for (int i = 0; i \u0026lt; 2400; i++) { // 從00:00~24:00(不含) for (int j = 0; j \u0026lt; city_num; j++) { // 最多共city_num座城市 if (dp[i][j] == -1) continue; for (int k = 0; k \u0026lt; G[j].size(); k++) { if (G[j][k].startTime \u0026gt;= i) { dp[G[j][k].endTime][G[j][k].cityNo] = max(dp[G[j][k].endTime][G[j][k].cityNo], dp[i][j]); } } } if (dp[i][endNum] != -1) { printf(\u0026#34;Departure %04d \u0026#34;, dp[i][endNum]); cout \u0026lt;\u0026lt; startCity \u0026lt;\u0026lt; endl; printf(\u0026#34;Arrival %04d \u0026#34;, i); cout \u0026lt;\u0026lt; endCity \u0026lt;\u0026lt; endl; has_solution = true; break; } } if (!has_solution) puts(\u0026#34;No connection\u0026#34;); puts(\u0026#34;\u0026#34;); } return 0; } ","permalink":"https://flyotlin.github.io/posts/uva-10039---railroads/","summary":"\u003ch2 id=\"題目敘述\"\u003e題目敘述\u003c/h2\u003e\n\u003cp\u003e這題輸入滿複雜的，分為三個部分，會先輸入有幾組測資。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePART 1:\n城市名稱\u003c/li\u003e\n\u003cli\u003ePART 2:\n列車資訊\u003c/li\u003e\n\u003cli\u003ePART 3:\n出發時間 出發城市 抵達城市\n\u003c!-- raw HTML omitted --\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003cp\u003e這題第一眼看到以為是dfs+圖論，但後來看了別人的解法後才發現是dp。\u003c/p\u003e","title":"Uva 10039 - Railroads"},{"content":"題目 題目給大象的體重及智商，求體重嚴格遞增，智商嚴格遞減的最長子集合(subset)。\n解題想法 我們可以先將體重由小到大排序(也可以智商由大到小排序，後面就反著做)，再對智商做LDS。但要注意體重跟智商的值有可能相等，所以在對智商做LDS的時候，也要注意體重沒有取到相等的值。\n參考: Longest Increasing Subsequence\n程式碼 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef struct { int num, weight, iq; } triple; bool cmp(triple \u0026amp;a, triple \u0026amp;b) { return a.weight \u0026lt; b.weight; } int length[1000]; int prev_iq[1000]; int main() { int a, b, no = 1; vector\u0026lt;triple\u0026gt; elephants; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { triple tmp; tmp.num = no++; tmp.weight = a; tmp.iq = b; elephants.push_back(tmp); } sort(elephants.begin(), elephants.end(), cmp); for (int i = 0; i \u0026lt; elephants.size(); i++) { length[i] = 1; prev_iq[i] = -1; } for (int i = 0; i \u0026lt; elephants.size(); i++) { for (int j = 0; j \u0026lt; i; j++) { if (elephants[i].iq \u0026lt; elephants[j].iq \u0026amp;\u0026amp; elephants[i].weight \u0026gt; elephants[j].weight) { // 前面條件為智商，後面條件為確保體重沒取到相等的 if (length[j] + 1 \u0026gt; length[i]) { length[i] = length[j] + 1; prev_iq[i] = j; } } } } int lis_length = -1234, maxIdx = 0; for (int i = 0; i \u0026lt; elephants.size(); i++) { if (length[i] \u0026gt; lis_length) { lis_length = length[i]; maxIdx = i; } } cout \u0026lt;\u0026lt; lis_length \u0026lt;\u0026lt; endl; vector\u0026lt;int\u0026gt; lis; while (maxIdx != -1) { lis.push_back(maxIdx); maxIdx = prev_iq[maxIdx]; } for (int i = lis.size() - 1; i \u0026gt;= 0; i--) cout \u0026lt;\u0026lt; elephants[lis[i]].num \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://flyotlin.github.io/posts/uva-10131---is-bigger-smarter/","summary":"\u003ch2 id=\"題目\"\u003e題目\u003c/h2\u003e\n\u003cp\u003e題目給大象的體重及智商，求體重\u003cstrong\u003e嚴格\u003c/strong\u003e遞增，智商\u003cstrong\u003e嚴格\u003c/strong\u003e遞減的最長子集合(subset)。\u003c/p\u003e\n\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003cp\u003e我們可以先將體重由小到大排序(也可以智商由大到小排序，後面就反著做)，再對智商做LDS。但要注意體重跟智商的值有可能相等，所以在對智商做LDS的時候，也要注意體重沒有取到相等的值。\u003c/p\u003e","title":"Uva 10131 - Is Bigger Smarter?"},{"content":"解題想法 先按照烏龜的力量由小到大排序。\n再依序檢查每隻烏龜，從塔的下方試試看，如果他的力量夠大，且重量比原本的輕就放進去。\ndp[i]: 儲存第i層烏龜塔所承受的總重量\nif dp[i-1] + turtle[i].weight \u0026lt; turtle[i].strength dp[i] = min{dp[i], dp[i-1] + turtle[i].weight} 有點LIS的味道，同樣是檢查此元素(數字/烏龜)是否能接到這個地方，但烏龜塔這題會從塔的下方檢查上去。\n如果從反方向，可能會因為這層的承受重量被改過了，下一層就不是原本的那個承受重量。\n程式碼 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef struct { int weight, strength; } turtle; bool cmp(turtle \u0026amp;a, turtle \u0026amp;b) { if (a.strength == b.strength) return a.weight \u0026lt; b.weight; return a.strength \u0026lt; b.strength; } int dp[5610]; int main() { vector\u0026lt;turtle\u0026gt; vec; int a, b; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { turtle tmp; tmp.weight = a; tmp.strength = b; vec.push_back(tmp); } sort(vec.begin(), vec.end(), cmp); for (int i = 0; i \u0026lt; 5610; i++) dp[i] = 1e9; dp[0] = 0; for (int i = 1; i \u0026lt;= vec.size(); i++) for (int j = i; j \u0026gt; 0; j--) if (dp[j-1] + vec[i].weight \u0026lt; vec[i].strength) dp[j] = min(dp[j], dp[j-1] + vec[i].weight); int level = vec.size(); while (dp[level] == 1e9) level--; cout \u0026lt;\u0026lt; level \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://flyotlin.github.io/posts/uva-10154---weights-and-measures/","summary":"\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003cp\u003e先按照烏龜的力量由小到大排序。\u003c/p\u003e\n\u003cp\u003e再依序檢查每隻烏龜，從塔的下方試試看，如果他的力量夠大，且重量比原本的輕就放進去。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003edp[i]: 儲存第i層烏龜塔所承受的總重量\u003c/strong\u003e\u003c/p\u003e","title":"Uva 10154 - Weights and Measures"},{"content":"解題想法 題目要問的是給定一個金額，請問用{1, 5, 10, 25, 50}來湊的話，共有幾種不同的湊法。\n這題其實就是無限背包問題，所以會用到動態規劃的概念。只是把背包的限制重量變成題目欲湊出的金額。物品變成面額。 然後面額的數量沒有限制，隨你喜歡用多少就用多少。\n可以分別考慮加上每個面額後，能湊出該金額的方法數會如何變化。 也就是以下的這個轉移式:\ndp(金額) += dp(金額 - 當下面額)\n如果先考慮一個固定金額，再考慮每加上不同面額，方法數會有甚麼改變(就是把for迴圈內外顛倒)。這樣會造成在考慮方法數的時候會重複計算。\n拿十元來舉例\n首先加上 $9 的方法數($1 * 9, $5 + $1 * 4)\n再加上 $5 的方法數($1 * 5, $5)\n會發現 $9 的第二個方法跟 $5 的第一個方法，在分別加上 $1 以及 $5 後會變成相同的方法，這樣就重複計算到了。\n程式碼 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int dp[8000] = {1}; int coins[5] = {1, 5, 10, 25, 50}; for (int i = 0; i \u0026lt; 5; i++) { for (int j = 0; j \u0026lt; 8000; j++) { if (j - coins[i] \u0026gt;= 0) dp[j] += dp[j - coins[i]]; } } int money; while (cin \u0026gt;\u0026gt; money) cout \u0026lt;\u0026lt; dp[money] \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://flyotlin.github.io/posts/uva-674---coin-change/","summary":"\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003cp\u003e題目要問的是給定一個金額，請問用{1, 5, 10, 25, 50}來湊的話，共有幾種不同的湊法。\u003c/p\u003e\n\u003cp\u003e這題其實就是無限背包問題，所以會用到動態規劃的概念。只是把背包的限制重量變成題目欲湊出的金額。物品變成面額。\n然後面額的數量沒有限制，隨你喜歡用多少就用多少。\u003c/p\u003e","title":"Uva 674 - Coin Change"},{"content":"Loop 用ECX作為counter，下面的範例code會loop 5次\nmov ecx, 5 L: ; do something loop L FLAGS ALU中有這些FLAG，反映算術運算後的結果\nSign Flag: 當結果變成負數 Carry Flag: 當unsigned numbers超出範圍 Zero Flag: 當結果變成0 Overflow Flag: 當signed numbers超出範圍 ESI(Source Index) [esi] : dereference該位址的值\nmov al, [esi] ; [esi] dereference the value of the address of esi OFFSET 回傳一個指標\n.data array BYTE 1000 DUP(?) .code mov esi, OFFSET array STACK Stack在記憶體中的位置。其中你寫的程式碼、在程式碼中.data部分宣告的變數也會被存在記憶體如下圖的相對位置中。\n從上圖也可以發現，在stack越上面的元素，他的位址就越小。\n基本stack操作 push及pop的大小由暫存器、記憶體決定，但只能是4 byte或是2 byte\npush eax pop eax ESP (Stack pointer) 指向stack中的最上面的元素的一個暫存器。\n巢狀迴圈 stack一個很常見的用途就是巢狀迴圈。\n外層迴圈要進入內層迴圈時，先把外層迴圈counter(ECX)的值push進stack中，等到離開內層迴圈後再將外層迴圈counter(ECX)的值pop出來。\nmov ecx, 5 L1: ; do something push ecx mov ecx 10 L2: ; do something else loop L2 pop ecx loop L1 Procedures 有點類似高階語言的function\n怎麼寫一個Procedure [function名稱] PROC ; something you want procedures to do [function名稱] ENDP CALL 呼叫你的Procedure，把call XX那行接下來要執行的指令的位址先push到stack，ESP就會指向那個位址。再把EIP指向XX Procedure的第一行\nRET 把stack最上面的元素pop給EIP。其實就等於pop EIP。\nUSES 在進入procedure前保存指定的暫存器的值，結束後再回復到進入procedure前的值。\n算是個語法糖。剛進到procedure的時候先push到stack，離開時再從stack中pop出來。\nSample PROC USES EAX ; do something in procedure Sample ENDP ","permalink":"https://flyotlin.github.io/posts/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%802/","summary":"\u003ch1 id=\"loop\"\u003eLoop\u003c/h1\u003e\n\u003cp\u003e用ECX作為counter，下面的範例code會loop 5次\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e    mov ecx, 5\nL:\n    ; do something\n    loop L\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"flags\"\u003eFLAGS\u003c/h1\u003e\n\u003cp\u003eALU中有這些FLAG，反映算術運算後的結果\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSign Flag: 當結果變成負數\u003c/li\u003e\n\u003cli\u003eCarry Flag: 當unsigned numbers超出範圍\u003c/li\u003e\n\u003cli\u003eZero Flag: 當結果變成0\u003c/li\u003e\n\u003cli\u003eOverflow Flag: 當signed numbers超出範圍\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"esisource-index\"\u003eESI(Source Index)\u003c/h1\u003e\n\u003cp\u003e[esi] : dereference該位址的值\u003c/p\u003e","title":"組合語言筆記-2"},{"content":"Catalan Number https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0 https://blog.csdn.net/u011489043/article/details/77884434\n(0, 0) \u0026mdash;\u0026gt; (n, n) 矩陣相乘，結合律 括號總數 神秘的解題公式 https://www.twblogs.net/a/5baaee952b7177781a0eb263/\ndp(k, d): k對括號，深度不超過d的方法數\ndp(k, d)算法:\ndp(k, d) += summation(dp(i, d-1) * dp(k-1 - i, d)), i from 0 to k-1\n上面summation內的dp只有k-1個括號，所以表達形式如下:\n(A)B\n疑問一: 為甚麼summation內是用相乘的? 疑問二: 為甚麼特地讓summation內的括號總數是k-1，而非k。是特意為了方便dp而設計的嗎? 疑問三: 為甚麼dp(k, d)要是k對括號，深度不超過d的方法數，而非k對括號，深度為d的方法數。 欲求k對括號，深度為d的方法數\ndp(k, d) - dp(k, d-1)\n","permalink":"https://flyotlin.github.io/posts/uva-10157---expressions/","summary":"\u003ch1 id=\"catalan-number\"\u003eCatalan Number\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0\"\u003ehttps://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0\u003c/a\u003e\n\u003ca href=\"https://blog.csdn.net/u011489043/article/details/77884434\"\u003ehttps://blog.csdn.net/u011489043/article/details/77884434\u003c/a\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e(0, 0) \u0026mdash;\u0026gt; (n, n)\u003c/li\u003e\n\u003cli\u003e矩陣相乘，結合律\u003c/li\u003e\n\u003cli\u003e括號總數\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"神秘的解題公式\"\u003e神秘的解題公式\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.twblogs.net/a/5baaee952b7177781a0eb263/\"\u003ehttps://www.twblogs.net/a/5baaee952b7177781a0eb263/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003edp(k, d): k對括號，深度\u003cstrong\u003e不超過\u003c/strong\u003ed的方法數\u003c/p\u003e\n\u003cp\u003edp(k, d)算法:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003edp(k, d) += summation(dp(i, d-1) * dp(k-1 - i, d)), i from 0 to k-1\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e上面summation內的dp只有k-1個括號，所以表達形式如下:\u003c/p\u003e","title":"Uva 10157 - Expressions"},{"content":"前言 在上組合語言的時候，有個作業原本是要把一個變數初始化為十六進位的eeea，但眼殘如我不小心看成是要初始化為一個字串eeea。於是我稍微去理解了一下究竟在register以及memory中是如何儲存字串及字元的，也是因為這樣才誕生了這篇文章。\n字元是如何儲存的? 一般字元是以1byte(8bits)的大小，用ascii code的編碼方式儲存在register及memory中的。\n要驗證字元如何儲存的真實性可以寫簡單的assembly code加上windbg輕易的驗證。\n驗證 首先我先寫了個簡單的程式碼，把字元A放到eax暫存器中。 TITLE example.asm INCLUDE Irvine32.inc .data .code main EQU start@0 main PROC mov eax, \u0026#39;A\u0026#39; main ENDP END main 利用windbg來看看eax會變成怎樣 還沒執行mov eax, \u0026lsquo;A\u0026rsquo;時，eax為一個隨機的初始值 執行後，eax內的值的確變成了A的ascii code編碼65。這也驗證了字元在register及memory中是以1byte、ascii code編碼的方式儲存的。 字串是如何儲存的? 先說結論，字串依然是把字元一個一個存在register或memory中，每個字元仍舊佔1個byte。所以拿\u0026quot;EEEA\u0026quot;為例，總共會佔4*1byte(32bits)。\n接下來我們來猜測一下記憶體中\u0026quot;EEEA\u0026quot;會如何被儲存。\n以下是我們猜測的記憶體中儲存方式的示意圖，位元組順序以常見的little endian小端序表示。\nE E E A 69 69 69 65 高 記憶體位置低 接下來我們就來驗證一下這個是否正確吧!\n驗證 我們同樣先寫一個簡單的assembly來開始我們的實驗。 TITLE example.asm INCLUDE Irvine32.inc .data .code main EQU start@0 main PROC mov eax, \u0026#39;EEEA\u0026#39; ; 把字串EEEA放到eax中 main ENDP END main 用windbg來看看eax暫存器狀況 還沒執行mov eax, \u0026lsquo;EEEA\u0026rsquo;，為隨機的初始值 咦?執行後，eax變成了1162167617 我們回想起剛剛的表格，可以得到這個公式: 符合我們剛剛表格中的的猜測。\n公式解釋:\n以16為底是因為記憶體內儲存皆是以16進位來表示。 指數的6, 4, 2則是在16進位之下做了shift left的動作。不懂的話可以先從二進位的shift運算來了解。 ","permalink":"https://flyotlin.github.io/posts/%E6%9A%AB%E5%AD%98%E5%99%A8%E5%A6%82%E4%BD%95%E5%84%B2%E5%AD%98%E5%AD%97%E4%B8%B2%E5%8F%8A%E5%AD%97%E5%85%83/","summary":"\u003ch1 id=\"前言\"\u003e前言\u003c/h1\u003e\n\u003cp\u003e在上組合語言的時候，有個作業原本是要把一個變數初始化為十六進位的eeea，但眼殘如我不小心看成是要初始化為一個字串eeea。於是我稍微去理解了一下究竟在register以及memory中是如何儲存字串及字元的，也是因為這樣才誕生了這篇文章。\u003c/p\u003e","title":"暫存器如何儲存字串及字元?"},{"content":"大二上的組合語言學的是windows assembly，組譯器(assembler)為MASM。之後這系列的文章會用筆記的形式記錄一下組語大概學了些什麼東西。\n暫存器Register 位於cpu內，要做任何算術運算都需要把值放到暫存器內，再進行進一步的運算。 General Purpose Register eax ebx ecx edx Segment Register 之後學到會再補充\n變數 宣告在.data的directive內。存放位置與暫存器不同，位於記憶體Memory(RAM)內，而非CPU。\n宣告方式為 變數名稱 變數資料型態 數值\n資料型態: 下面有簡單介紹 數值: 沒有初始值(uninitialized)可以用?代替 decimal: 10, 999等 hexidecimal: 口口口h，字母開頭要補0 binary: 口口口b 字元字串: 也可以!但要注意大小以及overflow問題 資料型態 mov對於資料型態大小有所限制，也就是不能直接mov比較小的數值型態到比較大的數值型態中。\nBYTE (8bits) WORD (16bits) DWORD (32bits) QWORD (64bits) 上述四者前面加上S(signed)就能儲存正負數\n基本指令 mov (eip不能當目的地、不能記憶體移到記憶體) movzx movsx add sub shl: 向左邏輯移位 shr: 向右邏輯移位 sal: 向左算數移位 sar: 向右算數移位 neg 產生執行檔過程 Source File Object File Executable File assemble(using assembler) linking(using linker) .asm .obj (.o) .exe 基本程式碼 .data ; 變數 .code ; 程式碼 main EQU start@0 main PROC ; mov eax, 20 main ENDP END main Make.bat 組譯來源檔案(assemble)\nML /c /coff /Zi code.asm 連結目標檔案(linking)\nLINK /INCREMENTAL:no /debug /subsystem:console /entry:start /out:code.exe code.obj Kernel32.lib irvine32.lib user32.lib windbg windbg可以讓我們使用assembler及linker產生出來的執行檔來逐行檢視程式執行狀況。常用到的有watch，可以監控register目前數值狀況。Memory，可以看宣告變數的數值狀況\n來源 暫存器圖: https://ithelp.ithome.com.tw/articles/10222729 ","permalink":"https://flyotlin.github.io/posts/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%801/","summary":"\u003cp\u003e大二上的組合語言學的是windows assembly，組譯器(assembler)為MASM。之後這系列的文章會用筆記的形式記錄一下組語大概學了些什麼東西。\u003c/p\u003e","title":"組合語言筆記-1"},{"content":"前言 這部真的超好看的!總共有39集，其中有3個總集篇，可以選擇跳過。 我是在巴哈動畫瘋上觀看的，希望大家可以多多支持國內的正版平台。打開彈幕配上劇情也別有一番趣味~\n概述 本片背景場景位於義大利，描述了喬魯諾(夢想是成為流氓巨星)與他的夥伴們為了讓那不勒斯成為更好的地方，讓青少年們遠離毒品，而前往打倒義大利黑道組織「熱情」老闆迪亞波羅的故事。\n優點 首先我想先提第五部黃金之風的一些優點。\n這部作品跟荒木飛呂彥前面兩部作品星塵遠征軍以及不滅鑽石一樣都有替身這個設定的出現，替身是由人體的精神能力所產生的強大力量。我認為這部比起前兩部在替身這個部分更好的地方是，他不再像前兩不一樣只是單純描寫替身本身的強大、力量、速度，而是如同第一、第二部，加入了角色本身、角色之間的鬥智以及利用一些物理或是細微處觀察，再加上本身替身的能量，最終打倒敵人。我想這樣子的方式比起單純用力量取勝來的更加高明，也更加地吸引觀影者，並且引人入勝。\n這部作品也首度在主角團中加入了女性角色，這在之前的前四部之中是從未出現過的。這部由漫畫改編的動畫，其原本漫畫連載期間是1995年到1999年，在那個民風還較純樸，性別意識還未大量萌芽的時刻，能在這種如此硬派的漫畫中加入一個主要女性角色，我認為是非常具有前瞻性，在現在看來也十分的前衛。\n黃金之風中出現的敵人，主要是來追殺喬魯諾一行人，阻止他們繼續揭穿老闆迪亞波羅的真面目。比起前幾部中，中途出現阻止主角團繼續前進的敵人，黃金之風中所出現的敵人變化度更加多樣、更加有創意，在智力、聰明程度方面也有更顯著的成長。我想這是作者隨著時間歷練所激發出的創意，也讓我們看了更加過癮。敵人的替身能力有像是老化、血液追蹤、操控鐵元素、鏡中世界、縮小、時間刪除等等。這些不僅增加了劇情的創意程度，也增加了劇情張力。在觀看的同時，由於替身能力的複雜化，觀影者會更加期待究竟這個替身能力背後真正的能力是甚麼。畢竟不再是簡單的可以從一兩次的動作就看出他所有真正的能力。\n黑道組織熱情的老闆迪亞波羅所擁有的替身能力克里姆王(時間刪除)，可以說是本作之中最強大的替身能力。這也是我在本作之中看得最費心力，花了許多時間才真正了解這個替身究竟是對時間做了些什麼事情。我想這就是這部作品的高明之處，複雜、多樣、有創意且引人入勝的替身能力設定，讓人好奇卻又匪夷所思。\n這部動畫值得讚賞之處還有製作公司的用心，光是第二首片頭曲就製作了5-6個版本，有普通版、音效版、以及加入了特別動畫等等的版本。動畫之中的音效也更讓我們更能理解劇情，也更能把自己帶入那個畫面現場，彷彿真的親身經歷那個瞬間。替身能力的畫面特效也為這部作品增加了不少的分數。\n有一集是主要主角團中阿帕基的死亡，畫面帶到了他的靈魂遇到了他死去的警察同事，描述了他們之間的談話。警察同事最後說了以下這段話。\n我追求的並不只是一個結果，一旦只追求結果，人就容易想方設法抄近路，在抄近路的過程中，人又容易迷失真相，做事的幹勁也會消磨殆盡，我認為最重要的是想要追求真相的意志\n這段話我想為這部作品的名稱黃金之風，做了最好的詮釋，十分耐人尋味。\n本部作品中替身能力的命名也十分耐人尋味，大部分都是與樂團或是歌曲名稱有關。像是鋼鏈手指（スティッキィ・フィンガーズ），來自英國滾石樂團的專輯Sticky Fingers、憂鬱藍調（ムーディー・ブルース），來自英國搖滾樂團憂鬱藍調合唱團、青春歲月（グリーン・ディ），來自美國龐克樂團Green Days。\n缺點 接下來我想講的是這部作品之中我認為的缺點。\n這部作品一開始設定的最終魔王以及打倒魔王的理由其實就有點奇怪。喬魯諾的夢想成為流氓巨星雖然聽起來有點中二，但還算可以接受。接下來是另一個主角布加拉提，他的目標是讓青少年遠離毒品，使得那不勒斯成為更好的地方。他們的邏輯是為了達成他們的目標，必須把販賣毒品的黑道組織熱情的老闆給除掉。我認為加入黑道組織前就該有他們可能會暗中販賣毒品的心理預備。加入後不認同，而想要把老闆推翻實在是有點荒謬也有點奇怪。\n另外，本部主角喬魯諾其實在整部動畫當中出現的份量偏少，存在感有時候其實也偏弱。這或許跟作者當初在設定劇情的時候有些許的關係，導致其他主要主角團中的角色有點蓋過了主角喬魯諾的光環。\n總結 這部作品名為黃金之風，主要強調的就是黃金精神。就像上面警察所說的，最重要的是想追求真相的意志。主角們追求老闆真面目的意志，最終迎來勝利以及使得整個義大利能夠成為更好的地方，不再被毒品控制。儘管一路上有夥伴的死亡，但只要持續保有黃金精神，將這分精神傳承下去，並且保有繼續追求真相的意志，永不放棄，最終一定能達到目標的終點。\n","permalink":"https://flyotlin.github.io/posts/jojo%E7%9A%84%E5%A5%87%E5%B9%BB%E5%86%92%E9%9A%AA-%E9%BB%83%E9%87%91%E4%B9%8B%E9%A2%A8-%E5%BD%B1%E8%A9%95/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e這部真的超好看的!總共有39集，其中有3個總集篇，可以選擇跳過。\n我是在巴哈動畫瘋上觀看的，希望大家可以多多支持國內的正版平台。打開彈幕配上劇情也別有一番趣味~\u003c/p\u003e","title":"JOJO的奇幻冒險 黃金之風 影評"},{"content":"不知道大家有沒有過打開ubuntu之後，發現整個螢幕的顯示方向從原本的水平變成垂直，或者是方向整個不對的經驗。像是下面這樣…\n在查過一些網路上的資料之後，這個原因或許是因為筆電裡面內建的陀螺儀在搞鬼。\n如果要關掉ubuntu中內建的自動旋轉螢幕方向，可以點右上角的選單(本圖的桌面環境為gnome，其他的像KDE、Unity可能要再另外找找看)，紅色圈起來的那個按鈕就是控制ubuntu自動旋轉螢幕方向的元兇了!\n但上面的方法只能預防這類的情況發生，如果要「治療」這個狀況，貌似只能透過terminal指令來更改螢幕方向。所以今天要介紹的是linux內建的指令xrandr。\nXRandR - (X Rotate and Reflect Extension)，顧名思義就是用來控制旋轉以及大小的。\n要把螢幕方向給他好好地轉回來，就直接打開terminal(快捷鍵:Alt+T)，輸入下面的指令。\n$ xrandr -o [the orientation螢幕方向]# 恢復正常 $ xrandr -o normal# 往左轉180度 $ xrandr -o left# 往右轉180度 $ xrandr -o right# 直接翻轉180度 $ xrandr -o inverted 查了一下arch linux官方有關於xrandr的文件之後，有一些更詳細的用法。\n# 直接顯示目前電腦有接上的輸出裝置的資訊 $ xrandr# 調整輸出裝置的設定 $ xrandr --output [輸出裝置，ex:HDMI-1] --mode [解析度，ex:1920x1080] --rate [更新頻率，ex:60] 其他還想知道更深入的用法可以去看看arch linux官方提供的文件。\nhttps://wiki.archlinux.org/index.php/Xrandr\n還有這篇x.org的manual，內容比上面arch linux提供的還要詳盡。\nhttps://www.x.org/releases/X11R7.5/doc/man/man1/xrandr.1.html\n","permalink":"https://flyotlin.github.io/posts/xrandr--linux%E8%9E%A2%E5%B9%95%E6%96%B9%E5%90%91%E8%A8%AD%E5%AE%9A%E6%95%99%E5%AD%B8/","summary":"\u003cp\u003e不知道大家有沒有過打開ubuntu之後，發現整個螢幕的顯示方向從原本的水平變成垂直，或者是方向整個不對的經驗。像是下面這樣…\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"fdfd\" loading=\"lazy\" src=\"https://i.imgur.com/aKI7tGO.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在查過一些網路上的資料之後，這個原因或許是因為筆電裡面內建的陀螺儀在搞鬼。\u003c/p\u003e","title":"Xrandr — Linux螢幕方向設定教學"},{"content":"題目連結: Uva455\n解題想法 輸入 第一行是1個整數n，代表有幾組測資。接下來每組測資都包含兩行，分別是空白行以及一個字串(最多80個字元)。\nSolve 題目要我們找出字串的最小週期\n一個字串最小週期的最大可能值是字串本身的長度，所以用for迴圈，假設i為可能最小週期，從i=1開始檢查到i=字串長度。\n由於最小週期一定要是字串長度的因數，也就是最小週期一定要能整除字串的長度。所以進到第一個for迴圈內後，用一個if檢查前面的陳述(假設的最小週期是否整除字串長度)是否為真。\n接下來是我在寫的時候想比較久的地方，用第二個for迴圈從字串的第一個字元檢查到最後一個字元，搭配if檢查該字串的最小週期是否如同我們假設的i。這個迴圈從頭檢查到尾，裡面的if檢查字元是否等於字元Mod最小週期。\n字元是否等於字元Mod最小週期 字串word: abcdabcd\na b c d a b c d\n0 1 2 3 4 5 6 7\n假設最小週期=2\nword[0] == word[0%2]\nword[1] == word[1%2]\nword[2] != word[2%2]\nword[3] != word[3%2]\nword[4] == word[4%2]\nword[5] == word[5%2]\nword[6] != word[6%2]\nword[7] != word[7%2]\n假設最小週期=4\nword[0] == word[0%2]\nword[1] == word[1%2]\nword[2] == word[2%2]\nword[3] == word[3%2]\nword[4] == word[4%2]\nword[5] == word[5%2]\nword[6] == word[6%2]\nword[7] == word[7%2]\n如果if檢查發現不同就直接跳出，假設大一點的最小週期。如果相同就繼續檢查，直到最後一個字元。\n在輸出的時候要注意格式，題目要求:\n對於每組測資輸出一個整數，表示輸入字串的最小period。 兩個連續的輸出由空白行分隔。\n空白行指的是每組測資的結果輸出後都要換行，最後一組就不用再換行，光是格式我就吃了好幾次的NA。\nC++程式碼 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { long long int k, n; while(cin \u0026gt;\u0026gt; k \u0026amp;\u0026amp; k != 0){ for(int i = 9; i \u0026gt;= 0; i--) { if((10*k-i)%9 == 0){ //先判斷是否整除 而非先直接除再判斷是否為整數 n = (10*k-i)/9.0; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; endl; } return 0; } 有興趣的可以參考一下~\n","permalink":"https://flyotlin.github.io/posts/uva-455---periodic-strings/","summary":"\u003cp\u003e題目連結: \u003ca href=\"https://onlinejudge.org/index.php?option=onlinejudge\u0026amp;page=show_problem\u0026amp;problem=396\"\u003eUva455\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003ch3 id=\"輸入\"\u003e輸入\u003c/h3\u003e\n\u003cp\u003e第一行是1個整數n，代表有幾組測資。接下來每組測資都包含兩行，分別是\u003cstrong\u003e空白行\u003c/strong\u003e以及\u003cstrong\u003e一個字串\u003c/strong\u003e(最多80個字元)。\u003c/p\u003e\n\u003ch3 id=\"solve\"\u003eSolve\u003c/h3\u003e\n\u003cp\u003e題目要我們找出字串的\u003cstrong\u003e最小週期\u003c/strong\u003e\u003c/p\u003e","title":"Uva 455 - Periodic Strings"},{"content":"題目 Uva 100- The 3n+1 problem\nf(n) = 3n+1 , n為奇數 – (1) = n/2 , n為偶數 – (2) 簡而言之，題目會input兩個數字(a, b)，藉由f(n)的運算，請你輸出依照input順序輸出a b，\n以及在a b之間最長的cycle length的長度。\n*cycle length:\n假設n=22，會依序跑出 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1，\n則f(22)的cycle length為16\n解題想法 題目給的定義為:\nf(n) = 3n+1 , n為奇數 – (1) = n/2 , n為偶數 – (2) f(n)結束的條件為n=1的時候\n其實這個定義在數學上叫做考拉茲猜想，有興趣可以去維基百科上了解更多。\n所以只要用while迴圈，條件為n != 1時，重複做(1) (2)的兩件事，直到n=1即可。\n要特別注意的是輸入的兩個數第二個不一定會大於第一個，所以程式中要注意\n兩個數的順序。\n此外，題目輸出時，前兩個要按照輸入時的順序輸出，然後第三個再輸出最長\n的cycle length。\nC++程式碼 #include \u0026lt;iostream\u0026gt; using namespace std; int three_n(int); int main() { int a, b; while(cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { int temp, aa, bb; if(a \u0026gt; b) { bb = a; aa = b; } else { aa = a; bb = b; } int max = 0; for(int i = aa; i \u0026lt;= bb; i++) { max = (three_n(i) \u0026gt; max) ? three_n(i) : max; } cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; max \u0026lt;\u0026lt; endl; } return 0; } int three_n(int n) { int count=0; while(n != 1) { if(n%2 == 1) { n = 3*n+1; count++; } else { n /= 2; count++; } } return count+1; } ","permalink":"https://flyotlin.github.io/posts/uva-100---the-3n-+-1-problem/","summary":"\u003ch2 id=\"題目\"\u003e題目\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;problem=36\"\u003eUva 100- The 3n+1 problem\u003c/a\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ef(n) = 3n+1 , n為奇數 – (1)\n\n     = n/2 , n為偶數  – (2)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e簡而言之，題目會input兩個數字(a, b)，藉由f(n)的運算，請你輸出依照input順序輸出a b，\u003c/p\u003e","title":"Uva 100 - The 3n + 1 Problem"},{"content":"題目連結: Uva10633\n解題想法 N, M\n其中M為N除去最小位數\n用數學式表達即 M = ( N - (N%10) ) / 10\n題目Input: N-M\n希望Output:所有可能的N\n首先從數學式著手 M = ( N - (N%10) ) / 10\n題目給的Input: N-M = N - ( N - (N%10) ) / 10\n所以 10(N-M) = 9N + (N%10)\n又N%10的可能解為0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n(10k, 10k+1, 10k+2, ……, 10k+9)\n到此題目就變得十分簡單明瞭了 跟名稱Easy一樣(重點誤)\n開個for迴圈 宣告i 從0 ~ 10\n首先檢查 10*(N-M) - (N%10) 是否被 9 整除\nif整除 則計算N的值 並將他輸出\n題目測資可能會有10^16次方大 記得用long long儲存\nC++程式碼 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { long long int k, n; while(cin \u0026gt;\u0026gt; k \u0026amp;\u0026amp; k != 0){ for(int i = 9; i \u0026gt;= 0; i--) { if((10*k-i)%9 == 0){ //先判斷是否整除 而非先直接除再判斷是否為整數 n = (10*k-i)/9.0; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; endl; } return 0; } ","permalink":"https://flyotlin.github.io/posts/uva-10633---rare-easy-problem/","summary":"\u003cp\u003e題目連結: \u003ca href=\"https://onlinejudge.org/index.php?option=onlinejudge\u0026amp;page=show_problem\u0026amp;problem=1574\"\u003eUva10633\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003cp\u003eN, M\u003c/p\u003e\n\u003cp\u003e其中M為N除去最小位數\u003c/p\u003e\n\u003cp\u003e用數學式表達即 M = ( N - (N%10) ) / 10\u003c/p\u003e\n\u003cp\u003e題目Input: N-M\u003c/p\u003e\n\u003cp\u003e希望Output:所有可能的N\u003c/p\u003e\n\u003cp\u003e首先從數學式著手 M = ( N - (N%10) ) / 10\u003c/p\u003e","title":"Uva 10633 - Rare Easy Problem"},{"content":"I am flyotlin, you can call me Nick also, a graduate student in NYCU CS now.\nLove coding, loving things, and helping other people.\nI\u0026rsquo;m now interested in Software Engineering, Software Testing, DevOps, and Distributed System.\nExperienced in Linux, C/C++, Python, JavaScript (Vue, Node.js), Golang, SQL, Docker, Unit test, CI/CD, Ansible.\nMy GitHub: https://github.com/flyotlin\nMy LinkedIn: https://www.linkedin.com/in/flyotlin\nMy Email: flyotlin@gmail.com\nPS., Learning Functional Programming (Haskell) now.\n","permalink":"https://flyotlin.github.io/about/","summary":"\u003cp\u003eI am flyotlin, you can call me Nick also, a graduate student in \u003ca href=\"https://cs.nycu.edu.tw/\"\u003eNYCU CS\u003c/a\u003e now.\u003c/p\u003e\n\u003cp\u003eLove coding, loving things, and helping other people.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m now interested in Software Engineering, Software Testing, DevOps, and Distributed System.\u003c/p\u003e\n\u003cp\u003eExperienced in Linux, C/C++, Python, JavaScript (Vue, Node.js), Golang, SQL, Docker, Unit test, CI/CD, Ansible.\u003c/p\u003e\n\u003cp\u003eMy GitHub: \u003ca href=\"https://github.com/flyotlin\"\u003ehttps://github.com/flyotlin\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMy LinkedIn: \u003ca href=\"https://www.linkedin.com/in/flyotlin\"\u003ehttps://www.linkedin.com/in/flyotlin\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMy Email: \u003ca href=\"mailto:flyotlin@gmail.com\"\u003eflyotlin@gmail.com\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ePS., Learning Functional Programming (Haskell) now.\u003c/p\u003e","title":"About Me"},{"content":"","permalink":"https://flyotlin.github.io/categories/","summary":"categories","title":"Categories"},{"content":"Experiences NCUFresh 20 NCUFresh 21 NCU 創新教學網站 NCPC 2021 Honorable Mention 2021 ICPC Asia Taipei Bronze Medal Software Engineer in Test (Intern) at Synology Projects BadmintonCourtAgent UML-Editor AutoDanmuGen Along with web UI visualization Solar System Orbit Simulation ","permalink":"https://flyotlin.github.io/cv/","summary":"cv","title":"CV"}]