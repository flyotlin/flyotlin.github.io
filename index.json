[{"content":"Go Hugo 是一個基於 Golang 產生靜態網站的 SSG (static site generation) 框架\n基本概念 site 一個 go hugo 產生的靜態網站\ncontent 網站中的靜態頁面、靜態內容\nconfiguration 設定 go hugo 產生的靜態網站 (site configuration)\n重要操作 create a site hugo new site\nadd content hugo new content \u0026lt;path-to-content\u0026gt;，網站的主題 (theme) 通常會被放在 /themes 底下。\ncontent 通常會用 font matter 格式，將 metadata 加在 content 上\nstart site hugo server 可以啟動一個開發用的網站\nconfigure site 透過 site configuration 設定 hugo 產生的靜態網站\npublish hugo 指令會將靜態網站 build 出來，將最終的靜態資源 (html, css, images, files) 放在 /public 資料夾中\n","permalink":"https://flyotlin.github.io/posts/go-hugo/","summary":"\u003cp\u003eGo Hugo 是一個基於 Golang 產生靜態網站的 SSG (static site generation) 框架\u003c/p\u003e\n\u003ch2 id=\"基本概念\"\u003e基本概念\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003esite\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e一個 go hugo 產生的靜態網站\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003econtent\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e網站中的靜態頁面、靜態內容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003econfiguration\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e設定 go hugo 產生的靜態網站 (site configuration)\u003c/p\u003e\n\u003ch2 id=\"重要操作\"\u003e重要操作\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ecreate a site\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ehugo new site\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eadd content\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ehugo new content \u0026lt;path-to-content\u0026gt;\u003c/code\u003e，網站的主題 (theme) 通常會被放在 \u003ccode\u003e/themes\u003c/code\u003e 底下。\u003c/p\u003e","title":"Go Hugo"},{"content":"git submodules 當你的專案需要依賴於外部的 git repo、library 時，可以透過 git submodule 將該外部依賴引入至你的專案中。\ngit submodule 會將外部依賴的某個 commit 引入到你的 repo 中。\nHow to use? 查看 submodule git submodule status\n初始化 submodule 當你 clone 一個有 submodule 的專案時，需要先透過 git submodule init 初始化被定義在 .gitsubmodules 中的外部依賴。\n接著，在透過 git submodule update 更新 submodule。\n以上兩個步驟可以透過 git submodule update --init --recursive 合併在一起。\n新增 submodule 透過指令 git submodule add \u0026lt;repository_url\u0026gt; \u0026lt;submodule directory path\u0026gt;，將某個外部 repo 從指定的 url clone 到指定的 path。\n更新 submodule 可以直接在 submodule 的資料夾變更檔案、commit 改動、push 到遠端 repo，你的 repo 會記錄目前 repo 正在使用的 submodule 的 commit。\n刪除 submodule 執行 git rm \u0026lt;path-to-submodule\u0026gt;，再 commit 改動到遠端 repo。\nRef Perplexity thread https://stackoverflow.com/questions/1260748/how-do-i-remove-a-submodule ","permalink":"https://flyotlin.github.io/posts/git-submodules/","summary":"\u003ch2 id=\"git-submodules\"\u003egit submodules\u003c/h2\u003e\n\u003cp\u003e當你的專案需要依賴於外部的 git repo、library 時，可以透過 git submodule 將該外部依賴引入至你的專案中。\u003c/p\u003e\n\u003cp\u003egit submodule 會將外部依賴的某個 commit 引入到你的 repo 中。\u003c/p\u003e\n\u003ch2 id=\"how-to-use\"\u003eHow to use?\u003c/h2\u003e\n\u003ch3 id=\"查看-submodule\"\u003e查看 submodule\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003egit submodule status\u003c/code\u003e\u003c/p\u003e","title":"Git Submodules"},{"content":"這兩題都算滿簡單的，所以放在一起講。\nhttps://leetcode.com/problems/string-to-integer-atoi\nhttps://leetcode.com/problems/palindrome-number/\nSolution Leetcode 8 — string to integer atoi 這題只有一些邊界問題要討論，其實挺簡單的。\n邊界問題是 integer (int) 是否會 overflow，跟昨天的 Leetcode 7 有點像。\n把數字字元加到 int 變數 n 時，正負數會分開處理。也就是正數用 + 的，負數用 - 的。\n判斷 overflow 則會分別判 INT_MAX 和 INT_MIN，但因為 res 已經是正負數，所以如果 overflow 發生，就直接把最大最小的邊界值給 res 就好。\n如果最後才考慮正負，res 恆為正，會發生 INT_MIN 沒辦法被表示在 res 裡面。\nLeetcode 9 — Palindrome number naive solution 是把數字轉字串，再檢查該字串是否為回文字串。\nfollow up 則是不轉成字串，嘗試直接檢查該數字是否為回文。\n","permalink":"https://flyotlin.github.io/posts/leetcode-8--9/","summary":"\u003cp\u003e這兩題都算滿簡單的，所以放在一起講。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/string-to-integer-atoi\"\u003ehttps://leetcode.com/problems/string-to-integer-atoi\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/palindrome-number/\"\u003ehttps://leetcode.com/problems/palindrome-number/\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003ch3 id=\"leetcode-8--string-to-integer-atoi\"\u003eLeetcode 8 — string to integer atoi\u003c/h3\u003e\n\u003cp\u003e這題只有一些邊界問題要討論，其實挺簡單的。\u003c/p\u003e\n\u003cp\u003e邊界問題是 integer (int) 是否會 overflow，跟昨天的 Leetcode 7 有點像。\u003c/p\u003e","title":"Leetcode 8 \u0026 9"},{"content":"很簡單的一個題目，唯一要注意的點是怎麼判斷 int overflow。\nhttps://leetcode.com/problems/reverse-integer Solution\n定義 n 為原本的數字。做法是用 % 取餘數，取得 n 的最小位數。接著再 n/10，持續這件事直到 n 為 0。\nn := original number rev := reverse of n while n != 0 remainder = n % 10 rev = 10 * rev + remainder 但要判斷反轉後的 n 是不是會 overflow。\nint 的範圍是 2³¹ -1 ~ -2³¹，也就是 2147483647 ~ -2147483648。\n根據上面的 pseudocode，可以知道 10*rev+remainder 可能造成 overflow，因此要特別檢查。\n10 * rev + remainder \u0026gt;= INT_MAX rev \u0026gt;= (INT_MAX - remainder) / 10\n如果 rev \u0026gt; INT_MAX，肯定會造成 overflow。\n如果 rev = INT_MAX，就要看 remainder。INT_MAX / 10 會把個位數的 7 去掉，所以當 remainder 大於 7，就會造成 overflow。\nINT_MIN 也是同理，當 remainder 小於 -8，就會 overflow。\nNote C/C++ 負數除法與取餘 cout \u0026lt;\u0026lt; 12 % 10 \u0026lt;\u0026lt; endl; // 2 cout \u0026lt;\u0026lt; 12 / 10 \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; -12 % 10 \u0026lt;\u0026lt; endl; // -2 cout \u0026lt;\u0026lt; -12 / 10 \u0026lt;\u0026lt; endl; // -1 cout \u0026lt;\u0026lt; -23 % 10 \u0026lt;\u0026lt; endl; // -3 cout \u0026lt;\u0026lt; -23 / 10 \u0026lt;\u0026lt; endl; // -2 跟正整數的除法、取餘一樣，只不過加上負號。\n跟 Python 負數取餘 (餘數不會是負的) 的行為不同，但跟 Javascript 的行為相同。\nC++ template 模板 template 其實就是泛型，可以將具體的資料型別抽離程式碼，在 compile time 透過 compiler 自動帶入型別 + 檢查。\ntemplate 分為兩種，function template 與 class template。\nexample:\n// funciton template template T add(T a, T b) { return a + b; }\n// class template template class MyClass { T\u0026amp; add(const T\u0026amp; a) { return *this; } };\nMyClass c1;\n通常動態型別的語言不需要 template/generic，因為本身就支援動態型別了，如 Python、Javascript。\n但像是 Typescript 因為引入型別，因此又支援 generics。\nRefs https://www.rocksaying.tw/archives/3641717.html ","permalink":"https://flyotlin.github.io/posts/leetcode-7--reverse-integer/","summary":"\u003cp\u003e很簡單的一個題目，唯一要注意的點是怎麼判斷 int overflow。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/reverse-integer\"\u003ehttps://leetcode.com/problems/reverse-integer\u003c/a\u003e\nSolution\u003c/p\u003e\n\u003cp\u003e定義 n 為原本的數字。做法是用 % 取餘數，取得 n 的最小位數。接著再 n/10，持續這件事直到 n 為 0。\u003c/p\u003e","title":"Leetcode 7 — Reverse Integer"},{"content":"想維持解題的規律跟手感，但最近實驗室還是會有些雜事 block 住，只能寫多少算多少了。\n目前還沒很進入找工作的狀態，可能是還有碩論跟雜事要忙，沒辦法全神貫注地投入。\nhttps://leetcode.com/problems/zigzag-conversion/\nSolution 這題其實沒什麼演算法，解法有以下兩種：\n1. 找出數學的規律 依序 concat 每個 zigzag row 的字元，要找出每個 row 的每個字元之間 index 的間隔。 以 PAYPALISHIRING，3 列為例，zigzag 字串會長成：\nP. A. H. N A P L S I I G Y. I R\n第一列的 index 是 0, 4, 8, …，與最後一列的規律一樣，都是 stride = 4，其中stride=2*row-2 。\n中間的列還要考慮會有其他的字元，所以 stride 不是單純的 2row-2。規律會變成 (stride-2i, 2 )，i 是當前的 row number。\n時間複雜度: O(n)\n空間複雜度: O(1)\n2. 用 2D array 儲存 zigzag 字串 先建立一個 2D 的 array，接著把 string 依照 zigzag 順序放到 2D array 中。最後再 row-by-row 地把字串印出來。\n時間複雜度: O(n)\n空間複雜度: O(n²)\n第二個解法的好處是想法單純，但當初第一次看到這題目並沒想到這想法，而是想用第一種解法，找出數學規律。\nNote std::unordered_set 底層是用 hash table 實作的，跟 std::set 的實作不同，std::set 底層是紅黑樹 （self balance binary tree）。\nset 是個 associative container (關聯式容器)，裡面只能儲存不重複的元素。\n如名字所述，一個有排序，一個沒有排序。排序指的是用 iterator 遍歷該容器時，是否會有序的遍歷容器內的元素。\nunordered_set 插入、查詢、刪除：O(1) 空間：O(n) 碰撞發生時，插入的 worst case time complexity 為 O(n) set 插入、刪除：avg O(1), worst O(logn) 查詢：O(logn) 空間：O(n) #include // 需要引入標頭檔 (header file) #include \u0026lt;unordered_set\u0026gt; #include using namespace std;\nint main() { set s; // unordered_set s; s.insert(1); s.insert(5); s.insert(2);\nfor (auto it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }\nhash table 能快速地將 key 對應到 value，屬於一種關聯式陣列 associative array。\n內部透過 hash function，將 key 轉換成 hash table 的 index，再從 table 的 index 把 value 取出。\n給定不同的 value，hash function 有可能計算出相同的 index，這種情況被稱作是 hash collision (碰撞)。\n關聯式陣列指的是有鍵值對應 (key-value) 的資料結構，又被稱為 map (對映) 或 dictionary (字典)。\nRef https://shengyu7697.github.io/std-unordered_set/ https://github.com/bradtraversy/traversy-js-challenges/blob/main/06-hash-tables-maps-sets/02-hash-table-intro/readme.md ","permalink":"https://flyotlin.github.io/posts/leetcode-6--zigzag-conversion/","summary":"\u003cp\u003e想維持解題的規律跟手感，但最近實驗室還是會有些雜事 block 住，只能寫多少算多少了。\u003c/p\u003e\n\u003cp\u003e目前還沒很進入找工作的狀態，可能是還有碩論跟雜事要忙，沒辦法全神貫注地投入。\u003c/p\u003e","title":"Leetcode 6 — Zigzag Conversion"},{"content":"https://leetcode.com/problems/longest-substring-without-repeating-characters\nSolution 使用 sliding window + set 就能解決這個問題，只是一開始被前幾天解的 dp 題 (找「最長回文子字串 longest palandromic substring」) 擾亂思緒，往列舉出所有長度的子字串，再一個個的檢查是否 valid 的方向思考。\n不過，這題 input string 長度是 10⁴，用列舉法的 TC 就至少是 O(n³)，肯定會 TLE。\n其實這題並沒有那麼複雜，可以用 sliding window 維護兩個 pointer (left \u0026amp; right)，由左往右慢慢更新。並且把當前的 window 範圍內出現過的 character 紀錄在 set 裡面。\n遇到沒看過的字元，就 right += 1。\n遇到看過的字元，就持續 left +=1，直到當前的 s(left, right) 不包含重複的字元。\nhttps://github.com/flyotlin/leetcode/blob/main/3-longest-substring-without-repeating-characters/1.cpp?source=post_page\u0026mdash;\u0026ndash;14ac3154b289\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nNote std::set // 初始化 std::set\u0026lt;int\u0026gt; s{1, 3, 4}; int arr\\[\\] = \\[1, 3, 5, 5\\]; std::set\u0026lt;int\u0026gt; s(arr, arr+4); // 從 c-style 的 array 初始化 // 插入 s.insert(1); // 查找 s.count(1); // 回傳純量，0 or 1 s.find(1); // 回傳 iterator，沒找到會回傳 s.end() // 刪除 s.erase(1); // 清空 s.clear(); std::unordered_set TBD\nRefs https://shengyu7697.github.io/std-set/ medium-to-markdown@0.0.3 convert node index.js https://medium.com/@flyotlin/leetcode-6-zigzag-conversion-70a90b71fb05\n","permalink":"https://flyotlin.github.io/posts/leetcode-3--longest-substring-without-repeating-characters/","summary":"\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters\"\u003ehttps://leetcode.com/problems/longest-substring-without-repeating-characters\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003cp\u003e使用 sliding window + set 就能解決這個問題，只是一開始被前幾天解的 dp 題 (找「最長回文子字串 longest palandromic substring」) 擾亂思緒，往列舉出所有長度的子字串，再一個個的檢查是否 valid 的方向思考。\u003c/p\u003e","title":"Leetcode 3 — Longest Substring Without Repeating Characters"},{"content":"https://leetcode.com/problems/median-of-two-sorted-arrays\nSolution 這題給你兩個 sorted array，請你找出這兩個 array 合併後的中位數。\nBrute force 測資的限制其實挺寬鬆的，雖然要求 O(log(m+n)) 的時間複雜度，但就算用 O(m+n) 的解法也是能 AC。\nbrute force 就單純的直接 merge 兩個 array，再直接計算 median 回傳。\nTwo pointers 在兩個 vector 上分別維護 pointer i, j，初始值為 0。迭代更新 i, j，如果 v1[i] ≤ v2[j]，就把 i 加一。\n更新過程中，也把最新的兩個 value 存到 m1, m2 中。\n持續以上的過程，直到累積 size/2 個 value，最後就能把 m1, m2 的 value 當作 median 回傳。\nhttps://github.com/flyotlin/leetcode/blob/main/4-median-of-two-sorted-array/2.cpp\nNote Vector initialization vector\u0026lt;int\u0026gt; vec = {1, 2, 3}; : Using initializer list vector\u0026lt;int\u0026gt; vec; vector\u0026lt;int\u0026gt; vec(num, value); : Initialize vector with num values vector\u0026lt;int\u0026gt; vec = {arr, arr+size}; vector\u0026lt;type\u0026gt; vec(v.begin(), v.end()); const for variables in C++ 一般的 scalar 在 stack 上的 scalar value 不能被修改 指標 依照 const 的位置，會導致 stack 上的 pointer 或 heap 上的實際內容不能被修改 // scalar const int num = 5; num = 6; // error\n// pointer (指標指向的 heap 內容不可修改) const char* name = \u0026ldquo;abc\u0026rdquo;;\n// pointer (在 stack 上的指標本身不可修改) char* const name = \u0026ldquo;abc\u0026rdquo;;\nconst for function in C++ const 加在 member function 前 不能修改 member function 的回傳值，通常用在 reference 上。 const 加在 member function 後 該 member function 不能修改 data member。 class Person { public: void toggle() const { int n = 2; n = 3; // ok\nname = \u0026quot;abc\u0026quot;; // compile-error }\nconst string\u0026amp; getName() { return this-\u0026gt;name; } private: string name; }\nint main() { Person p; const string\u0026amp; name = p.getName();\nname = \u0026ldquo;abc\u0026rdquo;; // compile-error }\nRefs https://www.geeksforgeeks.org/initialize-a-vector-in-cpp-different-ways/ https://shengyu7697.github.io/cpp-const/ ","permalink":"https://flyotlin.github.io/posts/leetcode-4--median-of-two-sorted-arrays/","summary":"\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/median-of-two-sorted-arrays\"\u003ehttps://leetcode.com/problems/median-of-two-sorted-arrays\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003cp\u003e這題給你兩個 sorted array，請你找出這兩個 array 合併後的中位數。\u003c/p\u003e\n\u003ch3 id=\"brute-force\"\u003eBrute force\u003c/h3\u003e\n\u003cp\u003e測資的限制其實挺寬鬆的，雖然要求 O(log(m+n)) 的時間複雜度，但就算用 O(m+n) 的解法也是能 AC。\u003c/p\u003e\n\u003cp\u003ebrute force 就單純的直接 merge 兩個 array，再直接計算 median 回傳。\u003c/p\u003e","title":"Leetcode 4 — Median of Two Sorted Arrays"},{"content":"前陣子在忙些雜事，刷題就荒廢了一陣子。途中還跑去學 Rust，之後可能會把 Rust book 重要的內容也整理一下，打成一篇筆記。\nhttps://leetcode.com/problems/longest-palindromic-substring/\n這題算標準的 Longest Palindromic Substring (最長回文子字串)，但很久沒寫這類題目，因此花了滿久卡在思考流程與邊界條件。\nSolution Brute Force 暴力 brute force 的想法是：\n從長度為 1 的子字串枚舉到長度為 n 的子字串，遇到是回文且較長，就更新 global 最大值。\n時間複雜度是 O(n³)，outer loop 是長度 1-n，inner loop 是枚舉該長度的所有字串 (n)，再加上檢查字串是否為回文。\nhttps://github.com/flyotlin/leetcode/blob/main/5-longest-palindromic-substring/3.cpp?source=post_page\u0026mdash;\u0026ndash;63aa3b4943e3\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nbrute force 雖然是 n³，但因為 input 限制字串長度為 1000，10⁹ 勉強能通過，不會 TLE。\n但要注意 memory 使用，字串直接放在 stack 上傳，可能會造成 memory limit exceed。\n把字串直接存在 heap 上就行了。\nDP 但仔細想想，這題目有點 dp (dynamic programming) 的味道。枚舉的過程中，短的字串會被包含在長的字串中。其實沒必要在看長的字串時，從頭開始檢查是否為回文。\n可以用一個 array dp(i, j)紀錄 s(i, j) 是否為回文。根據題目要求，也可以變化為紀錄 s(i, j) 的最長子回文長度。\n// 初始條件 dp(i, j) = false\n// 更新 dp(i, j) = true, if dp(i+1, j-1) = true = false, else\n但更新時要注意邊界，例如：\ni == j, =\u0026gt; 0 i \u0026gt; j, 這邊不會出現 j-1 \u0026lt; 0, 特判 dp(i,j) 更新後，就可以更新 global 最大值。\nManacher’s Algorithm TBD\nNote 如何判斷回文？ solve 1:\n利用兩個變數作為頭尾往中間靠攏，自己覺得比較直覺，不用思考字串奇偶長度的邊界問題。\nbool isPalindrome(string s) { int l = 0; int r = s.size() - 1;\nwhile (l \u0026lt;= r) { if (s[l] != s[r]) { return false; } l++, r\u0026ndash;; } return true; }\nsolve 2:\n出發點是「比較 size/2 次」，頭尾要自己計算，我覺得比較不直覺。\n奇數的部分，for 的 end condition 有等於，會比較中間的 char，沒有等於就不會比較到。可以直接省略等於。\nbool isPalindrome(string s) { for (int i = 0; i \u0026lt; s.size() / 2; i++) { if (s[i] != s[s.size() - i - 1]) { return false; } } return true; }\nmemset() declaration: void *memset(void *ptr, int value, size_t n);\nbool dp[100][100]; memset(dp, 5, sizeof(dp));\n使用 memset() 需要 include string.h (C) 或 cstring (C++)，可以將 ptr 指向的記憶體區塊 (n 個 byte) 設為 value 。\nmemset() 的單位是 byte，因此只適用於 bool、char 之類大小為 1 byte 的型別。\n像是 int 之類的型別 (4 bytes)，就不能用 memset() 來初始化。\nRefs https://web.ntnu.edu.tw/~algo/Palindrome.html https://leetcode.com/problems/longest-palindromic-substring/solutions/3202985/best-c-3-solution-dp-string-brute-force-optimize-one-stop-solution https://shengyu7697.github.io/cpp-memset/ ","permalink":"https://flyotlin.github.io/posts/leetcode-5--longest-palindromic-substring/","summary":"\u003cp\u003e前陣子在忙些雜事，刷題就荒廢了一陣子。途中還跑去學 Rust，之後可能會把 Rust book 重要的內容也整理一下，打成一篇筆記。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/longest-palindromic-substring/\"\u003ehttps://leetcode.com/problems/longest-palindromic-substring/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e這題算標準的 Longest Palindromic Substring (最長回文子字串)，但很久沒寫這類題目，因此花了滿久卡在思考流程與邊界條件。\u003c/p\u003e","title":"Leetcode 5 — Longest Palindromic Substring"},{"content":"接續昨天的選題，今天挑了一個 queue 相關的題目。\nhttps://leetcode.com/problems/implement-stack-using-queues\nSolution 題目的要求是使用兩個 queue (q1、q2) 來模擬 stack FILO 的行為。用紙筆簡單畫了一下，有了一點想法。\n主要的想法是，在 stack pop 前，push() 就只塞到其中一個 queue 裡面。\n在過程中，如果遇到：\nempty()：檢查兩個 queue 的 size top()：回傳當前 queue 的 back() 最後，當 stack pop() 的時候，持續 pop q1，並且將數值塞到 q2，直到 q1 為空。pop 的過程中，最後一個元素是 stack 的 top，要特別保留下來，並且不塞到 q2。\nNote STL Queue member functions:\npush() pop() front(): queue head, popped first back(): queue tail, popped last size() empty() C++ Class Class 是 OOP 為了達成資料抽象 (abstraction) 與資料封裝 (encapsulation) 的手段，用來區分介面 (interface) 與實作 (implementation)。\n在 C 的世界中，其實老早就有抽象的概念，將 declaration (.h) 與 definition (.c) 拆分開來。\n在 class 的實作中，可以不用加上 this，直接訪問被定義的 member data 或 function。\nC++ 的 class constructor 可以利用 initialization list 快速初始化 member data。\nC++ class 中的 this 是一個指向 object 本身的 pointer。\nC++ 的 class 還有 copy constructor、move constructor，還可以做 operator overloading，詳細的介紹之後有讀到再補充。（Rules of three/five）\nclass T { public: T() {} // constructor ~T() {} // destructor // member data // member function private: // members protected: // members };\nReference https://cplusplus.com/reference/queue/queue/ https://hackmd.io/@Mes/MinerT_Class ","permalink":"https://flyotlin.github.io/posts/leetcode-225--implement-stack-using-queues/","summary":"\u003cp\u003e接續昨天的選題，今天挑了一個 queue 相關的題目。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/implement-stack-using-queues\"\u003ehttps://leetcode.com/problems/implement-stack-using-queues\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003cp\u003e題目的要求是使用兩個 queue (q1、q2) 來模擬 stack FILO 的行為。用紙筆簡單畫了一下，有了一點想法。\u003c/p\u003e\n\u003cp\u003e主要的想法是，在 stack pop 前，push() 就只塞到其中一個 queue 裡面。\u003c/p\u003e","title":"Leetcode 225 — Implement Stack Using Queues"},{"content":"這幾天會找一些 stack、queue 的題目練習，主要圍繞在 C++ 的語法複習，以及基礎資料結構的熟悉。\nhttps://leetcode.com/problems/valid-parentheses\nSolution 標準的可以利用 stack FILO 特性的題目。\n解法就是單純的依序讀取字串，遇到的左括號放進 stack 中，遇到右括號就開始比對 stack top。\n如果跟 stack top 成對，就 pop stack；反之，則代表這是個不合法的 parentheses string。\nNote Stack 特性：FILO 可以用 array 或 linked list 實作 時間複雜度 插入：O(1)、搜尋：O(n) C++ STL container 以 sequence adapter 的方式實作 對 stack 操作前，要檢查 stack 是否是 empty。 否則會因為 stack 預設的 container 是以 linked list 實作的 deque，而踩到 SEGV (segmentation violation) Iterator “Iterate” is a technical term for looping.\nAn iterator is a pointer to the element inside a data structure.\nThough underlying data access mechanism is different, iterator provides a uniform interface to access data from either sequential or associative container. How to use Iterator?\nTake vector for example:\nvector vec = {1, 2, 3}; vector::iterator it;\n// forward for (it = vec.begin(); it != vec.end(); it++) { cout \u0026laquo; *it \u0026laquo; endl; }\n// backward (reverse) for (it = vec.rbegin(); it != vec.rend(); it++) { cout \u0026laquo; *it \u0026laquo; endl; }\nNote that vec.end() points to one position after the last element. Conclusion\n有空可以再手刻以 array 和 linked list 實作的 stack，而非直接使用 STL library 的 stack。\nReference https://web.ntnu.edu.tw/~algo/Data.html ","permalink":"https://flyotlin.github.io/posts/leetcode-20--valid-parentheses/","summary":"\u003cp\u003e這幾天會找一些 stack、queue 的題目練習，主要圍繞在 C++ 的語法複習，以及基礎資料結構的熟悉。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/valid-parentheses\"\u003ehttps://leetcode.com/problems/valid-parentheses\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003cp\u003e標準的可以利用 stack FILO 特性的題目。\u003c/p\u003e\n\u003cp\u003e解法就是單純的依序讀取字串，遇到的左括號放進 stack 中，遇到右括號就開始比對 stack top。\u003c/p\u003e","title":"Leetcode 20 — Valid Parentheses"},{"content":"接續前一天的策略，隨手從 Leetcode Linked List 題組中挑了一個 Hard 的題目。\n之前做過 Merge two Sorted Lists，這題算是那一題的變形、Follow-up。\nhttps://leetcode.com/problems/merge-k-sorted-lists\nSolution 看完題目後，偷瞄了一下 Topics 發現跟 heap、priority queue 有關。當下還沒仔細思考複雜度，但腦中瞬間有了一個解法。\n建立一個 priority_queue，遍歷所有 Linked Lists 中的 elements，並且加到 priority queue 裡面。\n接著再依序取 priority queue 的 top（最小值）並且 pop，直到 queue 變成空的。\n題目的限制是：\nLinked List 的數量: k (0 ≤ k ≤ 10⁴) Linked List 中元素個數: n (0 ≤ n ≤ 500) 最多有 10⁶ 個元素，時間複雜度會是 O(nk*ln(nk))，大約需要 10⁶ * ln10⁶ 次計算。\n空間複雜度是 O(nk)，因為需要一個儲存所有元素的 priority queue。\n不過，使用 priority queue 就沒辦法用到題目給的 sorted 的好處。AC 後看其他人的 solution 是 divide and conquer，就能利用到這個好處了。\nNote Priority Queue 是一個 heap 的結構，C++ STL (standard template library) 也有這個資料結構。\n在 C++ STL 實作中，priority queue 的 declaration 是：\ntemplate\u0026lt; class T, class Container = std::vector\u0026lt;T\u0026gt;, class Compare = std::less\u0026lt;typename Container::value\\_type\u0026gt; \\\u0026gt; class priority\\_queue; 預設會由大排到小，如果要由小到大，需要指定 Compare 為 std::greater\u0026lt;int\u0026gt;。\nCompare return true，會越晚從 priority queue 被 pop 出來。\n值得注意的是，STL container 有幾種類別：\nsequence containers\n如 array、vector、list、deque associative containers\n如 set、map unordered associative containers\n如 unordered_set、unordered_map 但，priority queue 其實並不屬於以上的任何一個類別。priority queue 是一個 container adaptor，用來提供不同的 interface 給 sequence container。\n這也是為什麼在 template 的 declaration 中，第二個 template parameter 會是 container。\nLeetcode address sanitizer 第一次寫完 submit 的時候發現會一直出現以下的錯誤：\nAddressSanitizer: attempting free on address which was not malloc()-ed 後來檢查了一下，在程式碼中有一個 ListNode *head;，沒有被初始化為一個 ListNode 的 object 或者是 nullptr。\nConclusion submit 出現的各種 error（如 AddressSanitizer）有空可以再更仔細的追究發生的原因。\n","permalink":"https://flyotlin.github.io/posts/leetcode-23--merge-k-sorted-lists/","summary":"\u003cp\u003e接續前一天的策略，隨手從 Leetcode Linked List 題組中挑了一個 Hard 的題目。\u003c/p\u003e\n\u003cp\u003e之前做過 Merge two Sorted Lists，這題算是那一題的變形、Follow-up。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/merge-k-sorted-lists\"\u003ehttps://leetcode.com/problems/merge-k-sorted-lists\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003cp\u003e看完題目後，偷瞄了一下 Topics 發現跟 heap、priority queue 有關。當下還沒仔細思考複雜度，但腦中瞬間有了一個解法。\u003c/p\u003e","title":"Leetcode 23 — Merge K Sorted Lists"},{"content":"最近開始刷題，先從基本的 data structure 開始複習。策略是主題式的複習，這幾天的目標是 array、linked list 之類的資料結構，因此從 leetcode array 類別中選到了這一題。\nhttps://leetcode.com/problems/container-with-most-water\nNaive Solution 這題乍看之下的 naive solution 是 O(n²)，把所有可能的長寬組合都暴力嘗試過一遍，Pseudocode 如下：\nmax_area = 0 for i = 1 ... n for j = i+1 ... n max_area = max(max_area, (j-i) * min(height[i], height[j])) 不過仔細觀察題目的限制 (constraints)，2 ≤ n ≤ 10⁵，以這種 O(n²) 的解法，複雜度會變成 10¹⁰，超過一般 CPU 可以在時間範圍內處理完的指令數。\n印象中一般在解這種題目的最大可接受複雜度是 10⁸ ~ 10⁹，超過的話通常會 TLE。（有錯請糾正我，知道 10⁸ 怎麼導出來的也可以告訴我，太久沒寫這類題目）\nReal Solution 這題其實可以利用 two pointer 的方法解決。\ntwo pointer 通常會用在 sorted array 或 sorted linked list 上，將 left、right pointer 分別設在左右兩個端點，利用 sorted 的特性，逐漸往中心收攏，探索最大的可能性，個人覺得有種 greedy 的味道。\n這題雖然沒有 sorted array，但有個特性是最大的底 * 最大的高，會得到最大的面積。\n一開始我們無法得知最大的高，因此可以先從最大的底探索，也就是把 two pointer 設在左右端點。\n接著，逐漸往中心靠攏，在過程中把較短的邊捨棄掉，探索最大的高。\n如此一來，就能將所有可能的最大面積都探索過一次。\nBonus Min \u0026amp; Max 在過程中用到 C++ 的 max 跟 min，就順手看了一下 cppreference 的介紹。\n如果 a, b 是一樣的 (equivalent)，會直接回傳 a。\n除了最基本的 max(a, b) 這樣的用法， max() 還有多個 overloaded 的實作。\n其中一種實作可以傳入 comp，改掉預設的 compare 行為。max 預設是 \u0026lt;，min 預設是 \u0026gt;，也可以自己傳入一個 binary function。 我想這個設計，是為了支援 object 之間的比較。因為預設的 \u0026gt;、\u0026lt; 只能比較 scalar，除非 object 的 class 有做 operator overloading。\n另一種實作可以傳入 il (initializer list)，讓 max、min 可以從一個 list 中找出最大、最小值。\n另外，max 跟 min 為了支援多種 data type，將資料型態從實作中抽離，背後是透過 C++ 的 template 實作的。\nInitializer List 根據 cppreference，initializer list 的 declaration 是 a list of elements of type const T 。\n可以透過 std::initializer_list 來定義\nstd::initializer_list\nConclusion 寫題目前要把題目的 constraints 看好，把時間、空間複雜度估好，不然很容易一 submit 就 TLE。\n","permalink":"https://flyotlin.github.io/posts/leetcode-11--container-with-most-water/","summary":"\u003cp\u003e最近開始刷題，先從基本的 data structure 開始複習。策略是主題式的複習，這幾天的目標是 array、linked list 之類的資料結構，因此從 leetcode array 類別中選到了這一題。\u003c/p\u003e","title":"Leetcode 11 — Container With Most Water"},{"content":"劇情簡介 某個虛構世界中某天突然出現了可以連結現實世界與異次元空間的傳送門，傳送門中充斥著各種魔獸。為了避免7天後封印解除，獵人們需要進入傳送門將魔獸清除。\n獵人分為S級、A-E級，主角振宇是最低的E級獵人。某次D級討伐任務中遇到雙重地下城，差點全員命喪第二座神殿地下城。地下城的三條戒律是崇拜神、讚美神，以及證明你的信仰。\n主角振宇戰鬥能力非常弱，每次都是討伐任務的拖油瓶，不過他的腦袋十分靈光。在神殿中成功靠著機智存活下來。\n心得 這部動畫是韓國原著漫畫與日本的A1-Pictures 合作改編而成的。起初對於韓國漫畫改編挺有興趣的，在這之前只知道webtoon，因此想了解現在韓國漫畫產業發展的狀況。另外，也是因為我近期十分喜愛的podcast曼報推薦，雙重誘因之下才開始看這部動畫。\n動畫的人物每個都畫的很精緻偏美型，這也許是韓漫的特色。\n動畫的日配唸出角色的韓文名字有點難記，也有種莫名好笑、奇怪的違和感。\n最吸引我繼續看下去的是，動畫的張力感十足，前兩三集振宇在討伐任務中出生入死，觀看過程中心也跟著揪著，真的十分刺激，看完之後都會期待下一集的發展。\n該噴番茄醬、發便當的地方也毫不手軟，有種比日漫更加黑暗的感覺。\n另一方面，主角的初始能力設定非常普通，在觀看過程中十分能將自己投射到主角上。因為主角就像是我們，一個什麼特殊能力都沒有的普通人。\n","permalink":"https://flyotlin.github.io/posts/%E6%88%91%E7%8D%A8%E8%87%AA%E5%8D%87%E7%B4%9A/","summary":"\u003ch2 id=\"劇情簡介\"\u003e劇情簡介\u003c/h2\u003e\n\u003cp\u003e某個虛構世界中某天突然出現了可以連結現實世界與異次元空間的傳送門，傳送門中充斥著各種魔獸。為了避免7天後封印解除，獵人們需要進入傳送門將魔獸清除。\u003c/p\u003e","title":"影評 - 我獨自升級"},{"content":"會想要看這部主因是新竹城隍廟附近的二輪戲院（新復珍戲院）最近上映的電影中，這部是我比較有興趣的。除了以天主教、梵蒂岡、驅魔為題材外，主演教廷驅魔士的羅素克洛也是吸引我的其中一點。\n題外話，當天最後一場電影票特價只要 110 元，爆米花 45 元，搭配飲料 65 元，算是滿經濟實惠的選擇，影廳內人不是太多，空間及座椅也十分舒適。螢幕大小、聲光效果也滿不錯的，本片剛好有一幕能體驗到影廳的環繞音效，音響體驗十分優良。唯一小缺點是當天去的時候，影廳內冷氣似乎不是很涼。\n劇情從介紹羅素克洛主演的驅魔士主角開始，安排了橋段讓主角小試身手，把惡魔轉移到黑豬上驅魔成功。老實說，看完電影後回想起這段，除了介紹外還真不知道安排這段的用意是什麼。接著鏡頭轉到西班牙的古老修道院，從美國來的 emily 一家打算整修過世父親的遺產，脫手後轉賣一筆。惡運就此而來，兒子 henry 被強大的邪靈附身，只得從羅馬請來教廷首席驅魔士來對抗惡魔。\n了解邪靈後，進行了各種驅魔儀式，emily 一家人以及主角、助手受到邪靈的各種惡搞、折磨、逼迫，就連遠在羅馬的教宗也受到強大邪靈的影響而導致病情加重。同時間，主角也發現了邪靈的計謀，找出了地底下中古世紀迫害異教徒的遺址，並且得知原來邪靈的目標是自己，過去邪靈也曾附身在一名驅魔士上，還有日記寫下了邪靈的名字。\n這樣好辦了，開始唸禱告文、信仰信念加 100、念出邪靈的名字，最後最重要的再用聖物進行物理驅魔，成功。片尾提到了還剩下 199 名邪靈，似乎在替續集埋伏筆。\n之前沒看過什麼驅魔片，有印象的是 2019 年韓國拍的「驅魔使者」，不過印象中是部爛片。這部片我覺得算滿好看的，或許當作動作+搞笑片，不要抱持著驅魔、驚悚片的期待去看比較不會失望。羅素克洛的搞笑以及不時脫口的笑話滿大程度緩和了劇情發展，這也是我以搞笑片角度觀賞本片的原因。\n我對基督、天主信仰與文化並不是這麼熟悉，片中帶出的修道院、教堂、教廷場景，驅魔士、神父口中的祝禱詞，劇情設定的200個墮入凡間的邪靈，有讓我想更深入了解奠定西方文化基礎的如此重要的信仰。片中告解的橋段我自己也覺得十分有趣，雖然之前就知道這項儀式，但看到實際在生活中對信仰者的意義及進行方式，還是頗新奇。整部片雖然以驅魔、天主教為題材，宗教意味並不濃厚，但驅魔成功是靠信仰、信任、愛，似乎是基督、天主宗教中的關鍵基礎。另外，或許是隨時間才逐步演變為此，基督、天主教對電影潮流文化向傳統文化的刺激與挑戰的包容，換作是佛教、伊斯蘭教的話，或許還無法接受這樣的衝擊吧。\n","permalink":"https://flyotlin.github.io/posts/%E6%A2%B5%E8%92%82%E5%B2%A1%E9%A9%85%E9%AD%94%E5%A3%AB/","summary":"\u003cp\u003e會想要看這部主因是新竹城隍廟附近的二輪戲院（新復珍戲院）最近上映的電影中，這部是我比較有興趣的。除了以天主教、梵蒂岡、驅魔為題材外，主演教廷驅魔士的羅素克洛也是吸引我的其中一點。\u003c/p\u003e","title":"梵蒂岡驅魔士"},{"content":"bash script 前面沒有特別設定的話，執行時遇到錯誤，通常會繼續往下執行，而不會像平常熟悉的程式語言遇到 exception 時（沒有 error handling）直接跳出結束執行。\n另外，在開發、撰寫 bash script 時，也時常有需要 debug 的時候。\n因此，以下簡單介紹一些常用且有幫助的 bash script 前置設定。\n以下設定只在 bash 上測試過，其他 shell 不一定能使用。\nset -x 在 bash script 開發過程中，如果需要 debug 可以在 script 前面加上 set -x。行為是 script 在執行時，執行每一行指令前，會先把指令印出來。\n雖然不像一些高階程式語言有 debugger 能設中斷點、直接觀察變數值以及 stack 狀況，但對於有許多變數、迴圈、邏輯判斷的複雜 script 來說，透過 print-debug like 的方式來找碴也十分有幫助。\nset -eou pipefail bash script 執行時遇到錯誤，以及遇到 unset variable 時，預設不會中斷而是會繼續執行。面對這種狀況，能在 script 前加上 set -eou pipefail 解決以上問題。\nArguments -e: 任何指令執行失敗會讓整個script跳出，return value非零。\n-u: unset variables would exit the script.\n-o pipefail: pipeline會把最後一個指令當作return value。\n使用此option後只要pipeline中任一指令失敗就會回傳非零。\n不過，要搭配-e才能避免失敗後繼續往下執行。\nTest -e:\n#!/bin/bash set -e # 請自行移除觀察行為有何差別 ls not-exist echo \u0026#34;HI\u0026#34; 加上 set -e 後就不會印出 HI，另外，echo $? 觀察 return value 也從 0 變成 1\n-u:\n#!/bin/bash set -u # 請自行移除觀察行為有何差別 echo \u0026#34;$notset\u0026#34; 加上 set -u 後第 5 行會報錯，另外，echo $? 觀察 return value 也從 0 變成 1\n-o pipefail\n#!/bin/bash set -o pipefail # 請自行移除觀察行為有何差別 ls not-exist | echo \u0026#34;HI\u0026#34; 加上 set -o pipefail 後 依然會繼續執行 pipeline 剩餘指令，因此能看到 stdout 印出 HI。\n原本 script 會把 pipeline 最後一個指令的 return 當作 return value，但加上此 option 後，只要 pipeline 中任何一個指令失敗，return\nvalue 就是 1，因此觀察到 return value 從 0 變成 1。\n#!/bin/bash set -o pipefail # 請自行移除觀察行為有何差別 echo \u0026#34;HI\u0026#34; | ls not-exist 這個範例無論有沒有加 set -o pipefail，return value 都是 1，原因與上面提到 pipeline 的 return value 機制有關。\n範例 Example sciprt #!/bin/bash set -eou pipefail set -x # your script... 結語 之後有遇到其他好用的設定會再慢慢更新上來\u0026hellip;\n","permalink":"https://flyotlin.github.io/posts/bash-script-shell-script-%E7%9A%84%E5%A5%BD%E7%BF%92%E6%85%A3/","summary":"\u003cp\u003ebash script 前面沒有特別設定的話，執行時遇到錯誤，通常會繼續往下執行，而不會像平常熟悉的程式語言遇到 exception 時（沒有 error handling）直接跳出結束執行。\u003c/p\u003e\n\u003cp\u003e另外，在開發、撰寫 bash script 時，也時常有需要 debug 的時候。\u003c/p\u003e","title":"Bash Script 的好習慣"},{"content":"從大一到大三，一直都很好奇宿舍網路的註冊及運作機制。但每次開通成功後，想要繼續深究的動力就直接消失。\n這次剛好在註冊、開通的過程遇到了些問題，就順手分享除錯過程，以及我對整個宿網運作機制的猜測及理解。\n沒辦法連上網路 起初對這個問題，做了幾個可能發生的假設。\nMAC address 填錯 Port number (A, B, C, D) 填錯 第 1 點是不可能的，畢竟從大一就用到現在。第 2 點在詢問後，也發現其實 port number 一點都不重要 ==。\n就在萬念俱灰之際，剛好逛到分享器設定頁面，發現外網 ip 怎麼不是 140.115.xxx.xxx！\n原本的假設是將分享器設定自動取得 IP (DHCP) 後，應該就會自動把 IP 設定為 140.115.xxx.xxx。但事與願違，只好手動觸發自動 IP 設定精靈，才解決了連線的問題。\nDHCP 在講宿網怎麼運作前，先來聊聊 DHCP。在古老的時代，終端設備要連上網路都只能透過手動設定 IP, Netmask, Gateway, DNS。\n於是就誕生了 DHCP，只要連上網路，就會自動設定 IP。\n連上網路的終端設備 (電腦) 會向整個網路發出 DHCP request 的廣播封包，裡面會包含設備的 MAC address。\n接著網路上的 DHCP server 收到這個封包，自動分配一個可用的 IP，並且將 IP 及相關的 netmask, gateway, DNS 夾帶在 DHCP response 封包中。\n最後，當設備收到 response 封包後，就能根據封包中資訊，正確設定網路的連線資訊。\nDHCP server 除了隨機自動分配可用 IP 外，也能夠幫特定設備 (以 MAC address 辨識) 保留一組 IP，MAC address 與 IP 的 mapping 則會記錄在 DHCP server 上的 reservation list。\n詳細還有關於 reservation list lease (租約) 過期的問題，推薦參考：\nDHCP Explained - Dynamic Host Configuration Protocol 動態主機設定協定 宿網的註冊 以下都是我的自行推論，有可能實際上並不是這麼運作。\n當你購買宿網授權，並且正確填入 MAC address 後，系統會分配一個 140.115.xxx.xxx 給你。\n同時，也會在校內網路 DHCP server 的 reservation list 紀錄分配的 140.115.xxx.xxx 要對應到你填的 MAC address。\n你的設備連上宿網後，會在校內網路發送 DHCP 的 request 廣播封包。被 DHCP server 收到後，根據 reservation list 的資訊，把你分配到的 IP 140.115.xxx.xxx 回傳給你。你的設備就能透過 DHCP response 的資訊正確上網了。\n宿網的阻擋機制 那宿網是怎麼阻擋沒有註冊的人使用網路呢？我的猜測是藉由 reservation list 中 IP 與 MAC address 的對應。\n當你要連到外部網路時，request 封包會通過校內網路的 gateway。學校計中或許在 gateway 的防火牆設置了 MAC address filter，過濾掉 IP 跟 MAC address 對應不起來的封包，進而實現了阻擋沒購買的人使用宿網。\n結語 我猜只要能夠偽造某個 IP 註冊的 MAC address，應該就能免費使用宿網了！\n但\u0026hellip; 恩，當我沒說 XD\n","permalink":"https://flyotlin.github.io/posts/%E9%97%9C%E6%96%BC%E4%B8%AD%E5%A4%AE%E5%AE%BF%E7%B6%B2%E7%9A%84%E9%80%99%E6%AA%94%E4%BA%8B/","summary":"\u003cp\u003e從大一到大三，一直都很好奇宿舍網路的註冊及運作機制。但每次開通成功後，想要繼續深究的動力就直接消失。\u003c/p\u003e\n\u003cp\u003e這次剛好在註冊、開通的過程遇到了些問題，就順手分享除錯過程，以及我對整個宿網運作機制的猜測及理解。\u003c/p\u003e","title":"關於中央宿網的這檔事"},{"content":"校內工讀的伺服器上部署了 3-4 個不同的網站，好在當初有使用 PHP 的容器化解決方案 - Laradock，能夠以容器化的方式使用多個服務。\n這次遇到的問題是 MySQL 對 arm64 (M1 Mac) 的支援度並不好，再加上沒有將前一次 Laradock 啟動後產生的 MySQL 檔案清乾淨，導致 local 啟動時踩了不少坑。\n接下來會直接簡述如何確保 M1 Mac 能順利啟動包含 MySQL 服務的 Laradock，最後才是 tedious 的 debug 過程。\nHow to Run Laradock with MySQL on M1 Mac Laradock .env 中的 MYSQL_VERSION 要指定為 arm64 版本的 image，如 8.0.29-oracle。 確保 ~/.laradock/data/ 中沒有 mysql 資料夾，否則會有存取問題。 MySQL support for ARM 一開始 Laradock build nginx, MySQL 時就會出現錯誤，原因是 MySQL latest image 並不支援 arm64 平台。\n稍微 google 後，許多 2021 年初的文章推薦直接在 pull image 時指定 platform 為 linux/x86_64。\n也發現其實 MySQL 開始支援 arm 平台，但需要另外指定對應的 tag。\n目前以 MySQL 8.0 以上帶有 oracle 後綴的 tag 為主。\nWeird MySQL Errors Google 了一下並經過思考後，我決定使用 arm64 版本的 MySQL image。但這也是一連串奇怪錯誤的開始\u0026hellip;\nFailed to Run MySQL 第一個是比較容易理解的錯誤，由於 Laradock 中的 MySQL 沒有順利啟動，其他依賴資料庫的 web 服務 (laradock) 當然也沒好受。\n最直接的錯誤是：\nphp_network_getaddresses: getaddrinfo failed: Temporary failure in name resolution\n很明顯問題是 MySQL 啟動失敗，web 服務沒辦法存取 MySQL。\n會出現 name resolution 錯誤是因為 Laradock 各個服務透過 docker-compose 啟動，彼此透過 service 名稱連線。\nMySQL 沒啟動，當然沒辦法將 MySQL service name (mysql) 解析成該容器對應的 private ip。\nLaradock 的大坑 發現是 MySQL 的錯誤後，緊接著檢查了 container logs 的錯誤訊息，分別發現了 2 個奇怪的錯誤。\nLinux Native AIO interface is not supported on this platform\nchown: cannot read directory '/var/lib/mysql/': Permission denied\n找了半天，在 docker-compose.yml 中看到了蛛絲馬跡。\n// from .env DATA_PATH_HOST=~/.laradock/data // from docker-compose.yml mysql: build: context: ./mysql args: - MYSQL_VERSION=${MYSQL_VERSION} environment: - MYSQL_DATABASE=${MYSQL_DATABASE} - MYSQL_USER=${MYSQL_USER} - MYSQL_PASSWORD=${MYSQL_PASSWORD} - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} - TZ=${WORKSPACE_TIMEZONE} volumes: - ${DATA_PATH_HOST}/mysql:/var/lib/mysql // 元兇！ - ${MYSQL_ENTRYPOINT_INITDB}:/docker-entrypoint-initdb.d ports: - \u0026#34;${MYSQL_PORT}:3306\u0026#34; networks: - backend 原來 Laradock build MySQL 時會把 MySQL 相關設定 mount 到 ~/.laradock/data/mysql，進而導致後續一連串的奇怪問題。\n","permalink":"https://flyotlin.github.io/posts/%E5%9C%A8-m1-mac-%E4%B8%8A%E5%95%9F%E5%8B%95-php-laradock/","summary":"\u003cp\u003e校內工讀的伺服器上部署了 3-4 個不同的網站，好在當初有使用 PHP 的容器化解決方案 - Laradock，能夠以容器化的方式使用多個服務。\u003c/p\u003e\n\u003cp\u003e這次遇到的問題是 MySQL 對 arm64 (M1 Mac) 的支援度並不好，再加上沒有將前一次 Laradock 啟動後產生的 MySQL 檔案清乾淨，導致 local 啟動時踩了不少坑。\u003c/p\u003e","title":"在 M1 Mac 上啟動 PHP Laradock"},{"content":"解題想法 這題用的演算法主要是dijkstra，求權重圖的最短路徑，但不能有負邊。\n由於題目給的是到終點時的貨物數量，要我們求起點出發要有多少貨物。 所以在這邊我們選擇從終點反向計算到各點的single-source shortest path。最後輸出終點到起點的shortest path。\n這題邊的權重可以看做是過路費，進到鄉村只收1單位貨物，進到城市則是每20個貨物收1單位貨物的過路費。\n因此dijkstra在進行relaxation的時候，要看該點權重加上進入該點的過路費，有沒有小於下個點權重，小於的話就更新下個點的shortest path。 上圖由A點更新其他點，更新後各點的狀況。\n另外，題目還需要輸出經過的地方。這個只需要用一個陣列pre[]來記錄他的上個點是誰即可。\n參考 我在學dijkstra的時候，看的是這位印度帥哥的教學影片。大推! Dijkstra - Abdul Bari\n程式碼 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; // 將abc轉為0~51的編碼 int decode(char x) { if (x \u0026gt;= 65 \u0026amp;\u0026amp; x \u0026lt;= 90) return x-65; if (x \u0026gt;= 97 \u0026amp;\u0026amp; x \u0026lt;= 122) return x-71; return 0; } // 將0~51的編碼轉回abc int encode(int x) { if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt;= 25) return x + 65; if (x \u0026gt;= 26 \u0026amp;\u0026amp; x \u0026lt;= 51) return x + 71; return 0; } long long INF = 0x7fffffffffff; // 無限大 int cases = 1; // 紀錄目前為第幾個case int main() { int path_num; char a, b, s, e; int aa, bb, start, end, item_num; while (cin \u0026gt;\u0026gt; path_num \u0026amp;\u0026amp; path_num != -1) { vector\u0026lt;int\u0026gt; map[60]; for (int i = 0; i \u0026lt; path_num; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; aa = decode(a); bb = decode(b); // 建圖 map[aa].push_back(bb); map[bb].push_back(aa); } cin \u0026gt;\u0026gt; item_num \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e; // 輸入題目問題 start = decode(s); end = decode(e); // 由end開始進行反向dijkstra int pre[60]; // 該點的前一個點 bool visit[60]; // 是否造訪過 long long d[60]; // 該點的最短路徑值 // 初始化 for (int i = 0; i \u0026lt; 60; i++) { pre[i] = -1; visit[i] = false; d[i] = INF; } queue\u0026lt;int\u0026gt; q; q.push(end); visit[end] = true; d[end] = item_num; int front, current, smaller_no; long long toll, smaller; while (!q.empty()) { front = q.front(); q.pop(); // 計算過路費 if (front \u0026gt;= 0 \u0026amp;\u0026amp; front \u0026lt;= 25) // 城市 toll = ceil(d[front] * 20.0 / 19.0); else // 鄉村 toll = d[front] + 1; // 進行dijkstra relaxation for (int i = 0; i \u0026lt; map[front].size(); i++) { current = map[front][i]; if (toll \u0026lt; d[current]) { d[current] = toll; pre[current] = front; } } // 挑選目前圖中，未造訪且權重最小的點 smaller = INF; for (int i = 0; i \u0026lt; 52; i++) if (visit[i] == false \u0026amp;\u0026amp; d[i] \u0026lt; smaller) { smaller = d[i]; smaller_no = i; } // 將點放到queue裡面 if (smaller \u0026lt; INF) { q.push(smaller_no); visit[smaller_no] = true; } } // 輸出答案 cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; cases++ \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; d[start] \u0026lt;\u0026lt; endl; current = start; while (current != end) { cout \u0026lt;\u0026lt; (char)encode(current) \u0026lt;\u0026lt; \u0026#34;-\u0026#34;; current = pre[current]; } cout \u0026lt;\u0026lt; (char)encode(current) \u0026lt;\u0026lt; endl; } return 0; } ","permalink":"https://flyotlin.github.io/posts/10537---the-toll-revisited/","summary":"\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003cp\u003e這題用的演算法主要是dijkstra，求權重圖的最短路徑，但不能有負邊。\u003c/p\u003e\n\u003cp\u003e由於題目給的是到終點時的貨物數量，要我們求起點出發要有多少貨物。\n所以在這邊我們選擇從終點反向計算到各點的single-source shortest path。最後輸出終點到起點的shortest path。\u003c/p\u003e","title":"10537 - The Toll! Revisited"},{"content":"題目敘述 這題輸入滿複雜的，分為三個部分，會先輸入有幾組測資。\nPART 1: 城市名稱 PART 2: 列車資訊 PART 3: 出發時間 出發城市 抵達城市 解題想法 這題第一眼看到以為是dfs+圖論，但後來看了別人的解法後才發現是dp。\ndp式子: dp[抵達時間][抵達城市] = 最晚出發時間\n初始設定:\n將整個dp array(最晚出發時間)設為-1，不能設為0(因為0代表00:00) 出發城市所有能到達的城市(k)，給定dp[抵達時間][k]的初始值。 轉移條件: dp[i][j] = max(dp[i][j], 到城市的最晚出發時間)\n解釋 G[startNum][i].startTime \u0026gt;= journey_startTime\n要能從出發城市(s)到下個城市(i)的話，就是上面的式子，\n條件為列車從s出發的時間比題目給的開始旅行時間晚。\nmax(dp[G[startNum][i].endTime][G[startNum][i].cityNo], G[startNum][i].startTime)\nG[startNum][i]: 為出發城市能到達的城市的節點 startTime: 列車出發的時間 endTime: 抵達該城市的時間 cityNo: 該抵達城市的編號 前面為原本的，後面是新的出發時間，兩者取較晚的。\nG[j][k].startTime \u0026gt;= i\nG[j][k].startTime 是到城市k的出發時間 i 是抵達城市j的時間 接著看看第四點\nmax(dp[G[j][k].endTime][G[j][k].cityNo], dp[i][j])\n前者是原本的，後者為什麼是dp[i][j]，以及為什麼第三點的條件式這樣呢?\n請看看下面這張圖\n所以dp[i][j]就是在某城市出發的時間，接著先到J，最後再到k。\n而要確保乘客能搭到這班車，條件就是由J往k的出發時間比i還晚，也就是第三點的條件。\n參考: Morris\n程式碼 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct edge { int cityNo, startTime, endTime; edge(int a, int b, int c): cityNo{a}, startTime{b}, endTime{c} {} }; vector\u0026lt;edge\u0026gt; G[105]; // 最多100個城市 int dp[2400][105]; // 抵達時間/城市編號 int main() { int test_cases, cases = 1; cin \u0026gt;\u0026gt; test_cases; int city_num; map\u0026lt;string, int\u0026gt; city_map; string tmp; while (test_cases--) { cin \u0026gt;\u0026gt; city_num; for (int i = 0; i \u0026lt; city_num; i++) { cin \u0026gt;\u0026gt; tmp; city_map[tmp] = i; G[i].clear(); } int train_num; cin \u0026gt;\u0026gt; train_num; for (int i = 0; i \u0026lt; train_num; i++) { int stop_num; cin \u0026gt;\u0026gt; stop_num; int time; // 輸入時的 時間 string station; // 輸入時的 車站 int prev_time; // 上次的 時間 string prev_station;// 上次的 車站 for (int j = 0; j \u0026lt; stop_num; j++) { cin \u0026gt;\u0026gt; time \u0026gt;\u0026gt; station; if (j != 0) G[city_map[prev_station]].push_back(edge(city_map[station], prev_time, time)); prev_station = station; prev_time = time; } } int journey_startTime; string startCity, endCity; cin \u0026gt;\u0026gt; journey_startTime \u0026gt;\u0026gt; startCity \u0026gt;\u0026gt; endCity; int startNum = city_map[startCity]; int endNum = city_map[endCity]; // Solve cout \u0026lt;\u0026lt; \u0026#34;Scenario \u0026#34; \u0026lt;\u0026lt; cases++ \u0026lt;\u0026lt; endl; // // 初始dp for (int i = 0; i \u0026lt; 2400; i++) for (int j = 0; j \u0026lt; 105; j++) dp[i][j] = -1; // 初始最晚出發時間為-1，0代表00:00(所以不能用) // 初始出發城市的dp狀態 for (int i = 0; i \u0026lt; G[startNum].size(); i++) { // G[startNum][i] if (G[startNum][i].startTime \u0026gt;= journey_startTime) dp[G[startNum][i].endTime][G[startNum][i].cityNo] = max(dp[G[startNum][i].endTime][G[startNum][i].cityNo], G[startNum][i].startTime); } bool has_solution = false; for (int i = 0; i \u0026lt; 2400; i++) { // 從00:00~24:00(不含) for (int j = 0; j \u0026lt; city_num; j++) { // 最多共city_num座城市 if (dp[i][j] == -1) continue; for (int k = 0; k \u0026lt; G[j].size(); k++) { if (G[j][k].startTime \u0026gt;= i) { dp[G[j][k].endTime][G[j][k].cityNo] = max(dp[G[j][k].endTime][G[j][k].cityNo], dp[i][j]); } } } if (dp[i][endNum] != -1) { printf(\u0026#34;Departure %04d \u0026#34;, dp[i][endNum]); cout \u0026lt;\u0026lt; startCity \u0026lt;\u0026lt; endl; printf(\u0026#34;Arrival %04d \u0026#34;, i); cout \u0026lt;\u0026lt; endCity \u0026lt;\u0026lt; endl; has_solution = true; break; } } if (!has_solution) puts(\u0026#34;No connection\u0026#34;); puts(\u0026#34;\u0026#34;); } return 0; } ","permalink":"https://flyotlin.github.io/posts/uva-10039---railroads/","summary":"\u003ch2 id=\"題目敘述\"\u003e題目敘述\u003c/h2\u003e\n\u003cp\u003e這題輸入滿複雜的，分為三個部分，會先輸入有幾組測資。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePART 1:\n城市名稱\u003c/li\u003e\n\u003cli\u003ePART 2:\n列車資訊\u003c/li\u003e\n\u003cli\u003ePART 3:\n出發時間 出發城市 抵達城市\n\u003c!-- raw HTML omitted --\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003cp\u003e這題第一眼看到以為是dfs+圖論，但後來看了別人的解法後才發現是dp。\u003c/p\u003e","title":"Uva 10039 - Railroads"},{"content":"題目 題目給大象的體重及智商，求體重嚴格遞增，智商嚴格遞減的最長子集合(subset)。\n解題想法 我們可以先將體重由小到大排序(也可以智商由大到小排序，後面就反著做)，再對智商做LDS。但要注意體重跟智商的值有可能相等，所以在對智商做LDS的時候，也要注意體重沒有取到相等的值。\n參考: Longest Increasing Subsequence\n程式碼 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef struct { int num, weight, iq; } triple; bool cmp(triple \u0026amp;a, triple \u0026amp;b) { return a.weight \u0026lt; b.weight; } int length[1000]; int prev_iq[1000]; int main() { int a, b, no = 1; vector\u0026lt;triple\u0026gt; elephants; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { triple tmp; tmp.num = no++; tmp.weight = a; tmp.iq = b; elephants.push_back(tmp); } sort(elephants.begin(), elephants.end(), cmp); for (int i = 0; i \u0026lt; elephants.size(); i++) { length[i] = 1; prev_iq[i] = -1; } for (int i = 0; i \u0026lt; elephants.size(); i++) { for (int j = 0; j \u0026lt; i; j++) { if (elephants[i].iq \u0026lt; elephants[j].iq \u0026amp;\u0026amp; elephants[i].weight \u0026gt; elephants[j].weight) { // 前面條件為智商，後面條件為確保體重沒取到相等的 if (length[j] + 1 \u0026gt; length[i]) { length[i] = length[j] + 1; prev_iq[i] = j; } } } } int lis_length = -1234, maxIdx = 0; for (int i = 0; i \u0026lt; elephants.size(); i++) { if (length[i] \u0026gt; lis_length) { lis_length = length[i]; maxIdx = i; } } cout \u0026lt;\u0026lt; lis_length \u0026lt;\u0026lt; endl; vector\u0026lt;int\u0026gt; lis; while (maxIdx != -1) { lis.push_back(maxIdx); maxIdx = prev_iq[maxIdx]; } for (int i = lis.size() - 1; i \u0026gt;= 0; i--) cout \u0026lt;\u0026lt; elephants[lis[i]].num \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://flyotlin.github.io/posts/uva-10131---is-bigger-smarter/","summary":"\u003ch2 id=\"題目\"\u003e題目\u003c/h2\u003e\n\u003cp\u003e題目給大象的體重及智商，求體重\u003cstrong\u003e嚴格\u003c/strong\u003e遞增，智商\u003cstrong\u003e嚴格\u003c/strong\u003e遞減的最長子集合(subset)。\u003c/p\u003e\n\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003cp\u003e我們可以先將體重由小到大排序(也可以智商由大到小排序，後面就反著做)，再對智商做LDS。但要注意體重跟智商的值有可能相等，所以在對智商做LDS的時候，也要注意體重沒有取到相等的值。\u003c/p\u003e","title":"Uva 10131 - Is Bigger Smarter?"},{"content":"解題想法 先按照烏龜的力量由小到大排序。\n再依序檢查每隻烏龜，從塔的下方試試看，如果他的力量夠大，且重量比原本的輕就放進去。\ndp[i]: 儲存第i層烏龜塔所承受的總重量\nif dp[i-1] + turtle[i].weight \u0026lt; turtle[i].strength dp[i] = min{dp[i], dp[i-1] + turtle[i].weight} 有點LIS的味道，同樣是檢查此元素(數字/烏龜)是否能接到這個地方，但烏龜塔這題會從塔的下方檢查上去。\n如果從反方向，可能會因為這層的承受重量被改過了，下一層就不是原本的那個承受重量。\n程式碼 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef struct { int weight, strength; } turtle; bool cmp(turtle \u0026amp;a, turtle \u0026amp;b) { if (a.strength == b.strength) return a.weight \u0026lt; b.weight; return a.strength \u0026lt; b.strength; } int dp[5610]; int main() { vector\u0026lt;turtle\u0026gt; vec; int a, b; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { turtle tmp; tmp.weight = a; tmp.strength = b; vec.push_back(tmp); } sort(vec.begin(), vec.end(), cmp); for (int i = 0; i \u0026lt; 5610; i++) dp[i] = 1e9; dp[0] = 0; for (int i = 1; i \u0026lt;= vec.size(); i++) for (int j = i; j \u0026gt; 0; j--) if (dp[j-1] + vec[i].weight \u0026lt; vec[i].strength) dp[j] = min(dp[j], dp[j-1] + vec[i].weight); int level = vec.size(); while (dp[level] == 1e9) level--; cout \u0026lt;\u0026lt; level \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://flyotlin.github.io/posts/uva-10154---weights-and-measures/","summary":"\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003cp\u003e先按照烏龜的力量由小到大排序。\u003c/p\u003e\n\u003cp\u003e再依序檢查每隻烏龜，從塔的下方試試看，如果他的力量夠大，且重量比原本的輕就放進去。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003edp[i]: 儲存第i層烏龜塔所承受的總重量\u003c/strong\u003e\u003c/p\u003e","title":"Uva 10154 - Weights and Measures"},{"content":"解題想法 題目要問的是給定一個金額，請問用{1, 5, 10, 25, 50}來湊的話，共有幾種不同的湊法。\n這題其實就是無限背包問題，所以會用到動態規劃的概念。只是把背包的限制重量變成題目欲湊出的金額。物品變成面額。 然後面額的數量沒有限制，隨你喜歡用多少就用多少。\n可以分別考慮加上每個面額後，能湊出該金額的方法數會如何變化。 也就是以下的這個轉移式:\ndp(金額) += dp(金額 - 當下面額)\n如果先考慮一個固定金額，再考慮每加上不同面額，方法數會有甚麼改變(就是把for迴圈內外顛倒)。這樣會造成在考慮方法數的時候會重複計算。\n拿十元來舉例\n首先加上 $9 的方法數($1 * 9, $5 + $1 * 4)\n再加上 $5 的方法數($1 * 5, $5)\n會發現 $9 的第二個方法跟 $5 的第一個方法，在分別加上 $1 以及 $5 後會變成相同的方法，這樣就重複計算到了。\n程式碼 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int dp[8000] = {1}; int coins[5] = {1, 5, 10, 25, 50}; for (int i = 0; i \u0026lt; 5; i++) { for (int j = 0; j \u0026lt; 8000; j++) { if (j - coins[i] \u0026gt;= 0) dp[j] += dp[j - coins[i]]; } } int money; while (cin \u0026gt;\u0026gt; money) cout \u0026lt;\u0026lt; dp[money] \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://flyotlin.github.io/posts/uva-674---coin-change/","summary":"\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003cp\u003e題目要問的是給定一個金額，請問用{1, 5, 10, 25, 50}來湊的話，共有幾種不同的湊法。\u003c/p\u003e\n\u003cp\u003e這題其實就是無限背包問題，所以會用到動態規劃的概念。只是把背包的限制重量變成題目欲湊出的金額。物品變成面額。\n然後面額的數量沒有限制，隨你喜歡用多少就用多少。\u003c/p\u003e","title":"Uva 674 - Coin Change"},{"content":"Loop 用ECX作為counter，下面的範例code會loop 5次\nmov ecx, 5 L: ; do something loop L FLAGS ALU中有這些FLAG，反映算術運算後的結果\nSign Flag: 當結果變成負數 Carry Flag: 當unsigned numbers超出範圍 Zero Flag: 當結果變成0 Overflow Flag: 當signed numbers超出範圍 ESI(Source Index) [esi] : dereference該位址的值\nmov al, [esi] ; [esi] dereference the value of the address of esi OFFSET 回傳一個指標\n.data array BYTE 1000 DUP(?) .code mov esi, OFFSET array STACK Stack在記憶體中的位置。其中你寫的程式碼、在程式碼中.data部分宣告的變數也會被存在記憶體如下圖的相對位置中。\n從上圖也可以發現，在stack越上面的元素，他的位址就越小。\n基本stack操作 push及pop的大小由暫存器、記憶體決定，但只能是4 byte或是2 byte\npush eax pop eax ESP (Stack pointer) 指向stack中的最上面的元素的一個暫存器。\n巢狀迴圈 stack一個很常見的用途就是巢狀迴圈。\n外層迴圈要進入內層迴圈時，先把外層迴圈counter(ECX)的值push進stack中，等到離開內層迴圈後再將外層迴圈counter(ECX)的值pop出來。\nmov ecx, 5 L1: ; do something push ecx mov ecx 10 L2: ; do something else loop L2 pop ecx loop L1 Procedures 有點類似高階語言的function\n怎麼寫一個Procedure [function名稱] PROC ; something you want procedures to do [function名稱] ENDP CALL 呼叫你的Procedure，把call XX那行接下來要執行的指令的位址先push到stack，ESP就會指向那個位址。再把EIP指向XX Procedure的第一行\nRET 把stack最上面的元素pop給EIP。其實就等於pop EIP。\nUSES 在進入procedure前保存指定的暫存器的值，結束後再回復到進入procedure前的值。\n算是個語法糖。剛進到procedure的時候先push到stack，離開時再從stack中pop出來。\nSample PROC USES EAX ; do something in procedure Sample ENDP ","permalink":"https://flyotlin.github.io/posts/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%802/","summary":"\u003ch1 id=\"loop\"\u003eLoop\u003c/h1\u003e\n\u003cp\u003e用ECX作為counter，下面的範例code會loop 5次\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e    mov ecx, 5\nL:\n    ; do something\n    loop L\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"flags\"\u003eFLAGS\u003c/h1\u003e\n\u003cp\u003eALU中有這些FLAG，反映算術運算後的結果\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSign Flag: 當結果變成負數\u003c/li\u003e\n\u003cli\u003eCarry Flag: 當unsigned numbers超出範圍\u003c/li\u003e\n\u003cli\u003eZero Flag: 當結果變成0\u003c/li\u003e\n\u003cli\u003eOverflow Flag: 當signed numbers超出範圍\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"esisource-index\"\u003eESI(Source Index)\u003c/h1\u003e\n\u003cp\u003e[esi] : dereference該位址的值\u003c/p\u003e","title":"組合語言筆記-2"},{"content":"Catalan Number https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0 https://blog.csdn.net/u011489043/article/details/77884434\n(0, 0) \u0026mdash;\u0026gt; (n, n) 矩陣相乘，結合律 括號總數 神秘的解題公式 https://www.twblogs.net/a/5baaee952b7177781a0eb263/\ndp(k, d): k對括號，深度不超過d的方法數\ndp(k, d)算法:\ndp(k, d) += summation(dp(i, d-1) * dp(k-1 - i, d)), i from 0 to k-1\n上面summation內的dp只有k-1個括號，所以表達形式如下:\n(A)B\n疑問一: 為甚麼summation內是用相乘的? 疑問二: 為甚麼特地讓summation內的括號總數是k-1，而非k。是特意為了方便dp而設計的嗎? 疑問三: 為甚麼dp(k, d)要是k對括號，深度不超過d的方法數，而非k對括號，深度為d的方法數。 欲求k對括號，深度為d的方法數\ndp(k, d) - dp(k, d-1)\n","permalink":"https://flyotlin.github.io/posts/uva-10157---expressions/","summary":"\u003ch1 id=\"catalan-number\"\u003eCatalan Number\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0\"\u003ehttps://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0\u003c/a\u003e\n\u003ca href=\"https://blog.csdn.net/u011489043/article/details/77884434\"\u003ehttps://blog.csdn.net/u011489043/article/details/77884434\u003c/a\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e(0, 0) \u0026mdash;\u0026gt; (n, n)\u003c/li\u003e\n\u003cli\u003e矩陣相乘，結合律\u003c/li\u003e\n\u003cli\u003e括號總數\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"神秘的解題公式\"\u003e神秘的解題公式\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.twblogs.net/a/5baaee952b7177781a0eb263/\"\u003ehttps://www.twblogs.net/a/5baaee952b7177781a0eb263/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003edp(k, d): k對括號，深度\u003cstrong\u003e不超過\u003c/strong\u003ed的方法數\u003c/p\u003e\n\u003cp\u003edp(k, d)算法:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003edp(k, d) += summation(dp(i, d-1) * dp(k-1 - i, d)), i from 0 to k-1\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e上面summation內的dp只有k-1個括號，所以表達形式如下:\u003c/p\u003e","title":"Uva 10157 - Expressions"},{"content":"前言 在上組合語言的時候，有個作業原本是要把一個變數初始化為十六進位的eeea，但眼殘如我不小心看成是要初始化為一個字串eeea。於是我稍微去理解了一下究竟在register以及memory中是如何儲存字串及字元的，也是因為這樣才誕生了這篇文章。\n字元是如何儲存的? 一般字元是以1byte(8bits)的大小，用ascii code的編碼方式儲存在register及memory中的。\n要驗證字元如何儲存的真實性可以寫簡單的assembly code加上windbg輕易的驗證。\n驗證 首先我先寫了個簡單的程式碼，把字元A放到eax暫存器中。 TITLE example.asm INCLUDE Irvine32.inc .data .code main EQU start@0 main PROC mov eax, \u0026#39;A\u0026#39; main ENDP END main 利用windbg來看看eax會變成怎樣 還沒執行mov eax, \u0026lsquo;A\u0026rsquo;時，eax為一個隨機的初始值 執行後，eax內的值的確變成了A的ascii code編碼65。這也驗證了字元在register及memory中是以1byte、ascii code編碼的方式儲存的。 字串是如何儲存的? 先說結論，字串依然是把字元一個一個存在register或memory中，每個字元仍舊佔1個byte。所以拿\u0026quot;EEEA\u0026quot;為例，總共會佔4*1byte(32bits)。\n接下來我們來猜測一下記憶體中\u0026quot;EEEA\u0026quot;會如何被儲存。\n以下是我們猜測的記憶體中儲存方式的示意圖，位元組順序以常見的little endian小端序表示。\nE E E A 69 69 69 65 高 記憶體位置低 接下來我們就來驗證一下這個是否正確吧!\n驗證 我們同樣先寫一個簡單的assembly來開始我們的實驗。 TITLE example.asm INCLUDE Irvine32.inc .data .code main EQU start@0 main PROC mov eax, \u0026#39;EEEA\u0026#39; ; 把字串EEEA放到eax中 main ENDP END main 用windbg來看看eax暫存器狀況 還沒執行mov eax, \u0026lsquo;EEEA\u0026rsquo;，為隨機的初始值 咦?執行後，eax變成了1162167617 我們回想起剛剛的表格，可以得到這個公式: 符合我們剛剛表格中的的猜測。\n公式解釋:\n以16為底是因為記憶體內儲存皆是以16進位來表示。 指數的6, 4, 2則是在16進位之下做了shift left的動作。不懂的話可以先從二進位的shift運算來了解。 ","permalink":"https://flyotlin.github.io/posts/%E6%9A%AB%E5%AD%98%E5%99%A8%E5%A6%82%E4%BD%95%E5%84%B2%E5%AD%98%E5%AD%97%E4%B8%B2%E5%8F%8A%E5%AD%97%E5%85%83/","summary":"\u003ch1 id=\"前言\"\u003e前言\u003c/h1\u003e\n\u003cp\u003e在上組合語言的時候，有個作業原本是要把一個變數初始化為十六進位的eeea，但眼殘如我不小心看成是要初始化為一個字串eeea。於是我稍微去理解了一下究竟在register以及memory中是如何儲存字串及字元的，也是因為這樣才誕生了這篇文章。\u003c/p\u003e","title":"暫存器如何儲存字串及字元?"},{"content":"大二上的組合語言學的是windows assembly，組譯器(assembler)為MASM。之後這系列的文章會用筆記的形式記錄一下組語大概學了些什麼東西。\n暫存器Register 位於cpu內，要做任何算術運算都需要把值放到暫存器內，再進行進一步的運算。 General Purpose Register eax ebx ecx edx Segment Register 之後學到會再補充\n變數 宣告在.data的directive內。存放位置與暫存器不同，位於記憶體Memory(RAM)內，而非CPU。\n宣告方式為 變數名稱 變數資料型態 數值\n資料型態: 下面有簡單介紹 數值: 沒有初始值(uninitialized)可以用?代替 decimal: 10, 999等 hexidecimal: 口口口h，字母開頭要補0 binary: 口口口b 字元字串: 也可以!但要注意大小以及overflow問題 資料型態 mov對於資料型態大小有所限制，也就是不能直接mov比較小的數值型態到比較大的數值型態中。\nBYTE (8bits) WORD (16bits) DWORD (32bits) QWORD (64bits) 上述四者前面加上S(signed)就能儲存正負數\n基本指令 mov (eip不能當目的地、不能記憶體移到記憶體) movzx movsx add sub shl: 向左邏輯移位 shr: 向右邏輯移位 sal: 向左算數移位 sar: 向右算數移位 neg 產生執行檔過程 Source File Object File Executable File assemble(using assembler) linking(using linker) .asm .obj (.o) .exe 基本程式碼 .data ; 變數 .code ; 程式碼 main EQU start@0 main PROC ; mov eax, 20 main ENDP END main Make.bat 組譯來源檔案(assemble)\nML /c /coff /Zi code.asm 連結目標檔案(linking)\nLINK /INCREMENTAL:no /debug /subsystem:console /entry:start /out:code.exe code.obj Kernel32.lib irvine32.lib user32.lib windbg windbg可以讓我們使用assembler及linker產生出來的執行檔來逐行檢視程式執行狀況。常用到的有watch，可以監控register目前數值狀況。Memory，可以看宣告變數的數值狀況\n來源 暫存器圖: https://ithelp.ithome.com.tw/articles/10222729 ","permalink":"https://flyotlin.github.io/posts/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%801/","summary":"\u003cp\u003e大二上的組合語言學的是windows assembly，組譯器(assembler)為MASM。之後這系列的文章會用筆記的形式記錄一下組語大概學了些什麼東西。\u003c/p\u003e","title":"組合語言筆記-1"},{"content":"前言 這部真的超好看的!總共有39集，其中有3個總集篇，可以選擇跳過。 我是在巴哈動畫瘋上觀看的，希望大家可以多多支持國內的正版平台。打開彈幕配上劇情也別有一番趣味~\n概述 本片背景場景位於義大利，描述了喬魯諾(夢想是成為流氓巨星)與他的夥伴們為了讓那不勒斯成為更好的地方，讓青少年們遠離毒品，而前往打倒義大利黑道組織「熱情」老闆迪亞波羅的故事。\n優點 首先我想先提第五部黃金之風的一些優點。\n這部作品跟荒木飛呂彥前面兩部作品星塵遠征軍以及不滅鑽石一樣都有替身這個設定的出現，替身是由人體的精神能力所產生的強大力量。我認為這部比起前兩部在替身這個部分更好的地方是，他不再像前兩不一樣只是單純描寫替身本身的強大、力量、速度，而是如同第一、第二部，加入了角色本身、角色之間的鬥智以及利用一些物理或是細微處觀察，再加上本身替身的能量，最終打倒敵人。我想這樣子的方式比起單純用力量取勝來的更加高明，也更加地吸引觀影者，並且引人入勝。\n這部作品也首度在主角團中加入了女性角色，這在之前的前四部之中是從未出現過的。這部由漫畫改編的動畫，其原本漫畫連載期間是1995年到1999年，在那個民風還較純樸，性別意識還未大量萌芽的時刻，能在這種如此硬派的漫畫中加入一個主要女性角色，我認為是非常具有前瞻性，在現在看來也十分的前衛。\n黃金之風中出現的敵人，主要是來追殺喬魯諾一行人，阻止他們繼續揭穿老闆迪亞波羅的真面目。比起前幾部中，中途出現阻止主角團繼續前進的敵人，黃金之風中所出現的敵人變化度更加多樣、更加有創意，在智力、聰明程度方面也有更顯著的成長。我想這是作者隨著時間歷練所激發出的創意，也讓我們看了更加過癮。敵人的替身能力有像是老化、血液追蹤、操控鐵元素、鏡中世界、縮小、時間刪除等等。這些不僅增加了劇情的創意程度，也增加了劇情張力。在觀看的同時，由於替身能力的複雜化，觀影者會更加期待究竟這個替身能力背後真正的能力是甚麼。畢竟不再是簡單的可以從一兩次的動作就看出他所有真正的能力。\n黑道組織熱情的老闆迪亞波羅所擁有的替身能力克里姆王(時間刪除)，可以說是本作之中最強大的替身能力。這也是我在本作之中看得最費心力，花了許多時間才真正了解這個替身究竟是對時間做了些什麼事情。我想這就是這部作品的高明之處，複雜、多樣、有創意且引人入勝的替身能力設定，讓人好奇卻又匪夷所思。\n這部動畫值得讚賞之處還有製作公司的用心，光是第二首片頭曲就製作了5-6個版本，有普通版、音效版、以及加入了特別動畫等等的版本。動畫之中的音效也更讓我們更能理解劇情，也更能把自己帶入那個畫面現場，彷彿真的親身經歷那個瞬間。替身能力的畫面特效也為這部作品增加了不少的分數。\n有一集是主要主角團中阿帕基的死亡，畫面帶到了他的靈魂遇到了他死去的警察同事，描述了他們之間的談話。警察同事最後說了以下這段話。\n我追求的並不只是一個結果，一旦只追求結果，人就容易想方設法抄近路，在抄近路的過程中，人又容易迷失真相，做事的幹勁也會消磨殆盡，我認為最重要的是想要追求真相的意志\n這段話我想為這部作品的名稱黃金之風，做了最好的詮釋，十分耐人尋味。\n本部作品中替身能力的命名也十分耐人尋味，大部分都是與樂團或是歌曲名稱有關。像是鋼鏈手指（スティッキィ・フィンガーズ），來自英國滾石樂團的專輯Sticky Fingers、憂鬱藍調（ムーディー・ブルース），來自英國搖滾樂團憂鬱藍調合唱團、青春歲月（グリーン・ディ），來自美國龐克樂團Green Days。\n缺點 接下來我想講的是這部作品之中我認為的缺點。\n這部作品一開始設定的最終魔王以及打倒魔王的理由其實就有點奇怪。喬魯諾的夢想成為流氓巨星雖然聽起來有點中二，但還算可以接受。接下來是另一個主角布加拉提，他的目標是讓青少年遠離毒品，使得那不勒斯成為更好的地方。他們的邏輯是為了達成他們的目標，必須把販賣毒品的黑道組織熱情的老闆給除掉。我認為加入黑道組織前就該有他們可能會暗中販賣毒品的心理預備。加入後不認同，而想要把老闆推翻實在是有點荒謬也有點奇怪。\n另外，本部主角喬魯諾其實在整部動畫當中出現的份量偏少，存在感有時候其實也偏弱。這或許跟作者當初在設定劇情的時候有些許的關係，導致其他主要主角團中的角色有點蓋過了主角喬魯諾的光環。\n總結 這部作品名為黃金之風，主要強調的就是黃金精神。就像上面警察所說的，最重要的是想追求真相的意志。主角們追求老闆真面目的意志，最終迎來勝利以及使得整個義大利能夠成為更好的地方，不再被毒品控制。儘管一路上有夥伴的死亡，但只要持續保有黃金精神，將這分精神傳承下去，並且保有繼續追求真相的意志，永不放棄，最終一定能達到目標的終點。\n","permalink":"https://flyotlin.github.io/posts/jojo%E7%9A%84%E5%A5%87%E5%B9%BB%E5%86%92%E9%9A%AA-%E9%BB%83%E9%87%91%E4%B9%8B%E9%A2%A8-%E5%BD%B1%E8%A9%95/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e這部真的超好看的!總共有39集，其中有3個總集篇，可以選擇跳過。\n我是在巴哈動畫瘋上觀看的，希望大家可以多多支持國內的正版平台。打開彈幕配上劇情也別有一番趣味~\u003c/p\u003e","title":"JOJO的奇幻冒險 黃金之風 影評"},{"content":"不知道大家有沒有過打開ubuntu之後，發現整個螢幕的顯示方向從原本的水平變成垂直，或者是方向整個不對的經驗。像是下面這樣…\n在查過一些網路上的資料之後，這個原因或許是因為筆電裡面內建的陀螺儀在搞鬼。\n如果要關掉ubuntu中內建的自動旋轉螢幕方向，可以點右上角的選單(本圖的桌面環境為gnome，其他的像KDE、Unity可能要再另外找找看)，紅色圈起來的那個按鈕就是控制ubuntu自動旋轉螢幕方向的元兇了!\n但上面的方法只能預防這類的情況發生，如果要「治療」這個狀況，貌似只能透過terminal指令來更改螢幕方向。所以今天要介紹的是linux內建的指令xrandr。\nXRandR - (X Rotate and Reflect Extension)，顧名思義就是用來控制旋轉以及大小的。\n要把螢幕方向給他好好地轉回來，就直接打開terminal(快捷鍵:Alt+T)，輸入下面的指令。\n$ xrandr -o [the orientation螢幕方向]# 恢復正常 $ xrandr -o normal# 往左轉180度 $ xrandr -o left# 往右轉180度 $ xrandr -o right# 直接翻轉180度 $ xrandr -o inverted 查了一下arch linux官方有關於xrandr的文件之後，有一些更詳細的用法。\n# 直接顯示目前電腦有接上的輸出裝置的資訊 $ xrandr# 調整輸出裝置的設定 $ xrandr --output [輸出裝置，ex:HDMI-1] --mode [解析度，ex:1920x1080] --rate [更新頻率，ex:60] 其他還想知道更深入的用法可以去看看arch linux官方提供的文件。\nhttps://wiki.archlinux.org/index.php/Xrandr\n還有這篇x.org的manual，內容比上面arch linux提供的還要詳盡。\nhttps://www.x.org/releases/X11R7.5/doc/man/man1/xrandr.1.html\n","permalink":"https://flyotlin.github.io/posts/xrandr--linux%E8%9E%A2%E5%B9%95%E6%96%B9%E5%90%91%E8%A8%AD%E5%AE%9A%E6%95%99%E5%AD%B8/","summary":"\u003cp\u003e不知道大家有沒有過打開ubuntu之後，發現整個螢幕的顯示方向從原本的水平變成垂直，或者是方向整個不對的經驗。像是下面這樣…\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"fdfd\" loading=\"lazy\" src=\"https://i.imgur.com/aKI7tGO.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在查過一些網路上的資料之後，這個原因或許是因為筆電裡面內建的陀螺儀在搞鬼。\u003c/p\u003e","title":"Xrandr — Linux螢幕方向設定教學"},{"content":"題目連結: Uva455\n解題想法 輸入 第一行是1個整數n，代表有幾組測資。接下來每組測資都包含兩行，分別是空白行以及一個字串(最多80個字元)。\nSolve 題目要我們找出字串的最小週期\n一個字串最小週期的最大可能值是字串本身的長度，所以用for迴圈，假設i為可能最小週期，從i=1開始檢查到i=字串長度。\n由於最小週期一定要是字串長度的因數，也就是最小週期一定要能整除字串的長度。所以進到第一個for迴圈內後，用一個if檢查前面的陳述(假設的最小週期是否整除字串長度)是否為真。\n接下來是我在寫的時候想比較久的地方，用第二個for迴圈從字串的第一個字元檢查到最後一個字元，搭配if檢查該字串的最小週期是否如同我們假設的i。這個迴圈從頭檢查到尾，裡面的if檢查字元是否等於字元Mod最小週期。\n字元是否等於字元Mod最小週期 字串word: abcdabcd\na b c d a b c d\n0 1 2 3 4 5 6 7\n假設最小週期=2\nword[0] == word[0%2]\nword[1] == word[1%2]\nword[2] != word[2%2]\nword[3] != word[3%2]\nword[4] == word[4%2]\nword[5] == word[5%2]\nword[6] != word[6%2]\nword[7] != word[7%2]\n假設最小週期=4\nword[0] == word[0%2]\nword[1] == word[1%2]\nword[2] == word[2%2]\nword[3] == word[3%2]\nword[4] == word[4%2]\nword[5] == word[5%2]\nword[6] == word[6%2]\nword[7] == word[7%2]\n如果if檢查發現不同就直接跳出，假設大一點的最小週期。如果相同就繼續檢查，直到最後一個字元。\n在輸出的時候要注意格式，題目要求:\n對於每組測資輸出一個整數，表示輸入字串的最小period。 兩個連續的輸出由空白行分隔。\n空白行指的是每組測資的結果輸出後都要換行，最後一組就不用再換行，光是格式我就吃了好幾次的NA。\nC++程式碼 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { long long int k, n; while(cin \u0026gt;\u0026gt; k \u0026amp;\u0026amp; k != 0){ for(int i = 9; i \u0026gt;= 0; i--) { if((10*k-i)%9 == 0){ //先判斷是否整除 而非先直接除再判斷是否為整數 n = (10*k-i)/9.0; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; endl; } return 0; } 有興趣的可以參考一下~\n","permalink":"https://flyotlin.github.io/posts/uva-455---periodic-strings/","summary":"\u003cp\u003e題目連結: \u003ca href=\"https://onlinejudge.org/index.php?option=onlinejudge\u0026amp;page=show_problem\u0026amp;problem=396\"\u003eUva455\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003ch3 id=\"輸入\"\u003e輸入\u003c/h3\u003e\n\u003cp\u003e第一行是1個整數n，代表有幾組測資。接下來每組測資都包含兩行，分別是\u003cstrong\u003e空白行\u003c/strong\u003e以及\u003cstrong\u003e一個字串\u003c/strong\u003e(最多80個字元)。\u003c/p\u003e\n\u003ch3 id=\"solve\"\u003eSolve\u003c/h3\u003e\n\u003cp\u003e題目要我們找出字串的\u003cstrong\u003e最小週期\u003c/strong\u003e\u003c/p\u003e","title":"Uva 455 - Periodic Strings"},{"content":"題目 Uva 100- The 3n+1 problem\nf(n) = 3n+1 , n為奇數 – (1) = n/2 , n為偶數 – (2) 簡而言之，題目會input兩個數字(a, b)，藉由f(n)的運算，請你輸出依照input順序輸出a b，\n以及在a b之間最長的cycle length的長度。\n*cycle length:\n假設n=22，會依序跑出 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1，\n則f(22)的cycle length為16\n解題想法 題目給的定義為:\nf(n) = 3n+1 , n為奇數 – (1) = n/2 , n為偶數 – (2) f(n)結束的條件為n=1的時候\n其實這個定義在數學上叫做考拉茲猜想，有興趣可以去維基百科上了解更多。\n所以只要用while迴圈，條件為n != 1時，重複做(1) (2)的兩件事，直到n=1即可。\n要特別注意的是輸入的兩個數第二個不一定會大於第一個，所以程式中要注意\n兩個數的順序。\n此外，題目輸出時，前兩個要按照輸入時的順序輸出，然後第三個再輸出最長\n的cycle length。\nC++程式碼 #include \u0026lt;iostream\u0026gt; using namespace std; int three_n(int); int main() { int a, b; while(cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { int temp, aa, bb; if(a \u0026gt; b) { bb = a; aa = b; } else { aa = a; bb = b; } int max = 0; for(int i = aa; i \u0026lt;= bb; i++) { max = (three_n(i) \u0026gt; max) ? three_n(i) : max; } cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; max \u0026lt;\u0026lt; endl; } return 0; } int three_n(int n) { int count=0; while(n != 1) { if(n%2 == 1) { n = 3*n+1; count++; } else { n /= 2; count++; } } return count+1; } ","permalink":"https://flyotlin.github.io/posts/uva-100---the-3n-+-1-problem/","summary":"\u003ch2 id=\"題目\"\u003e題目\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;problem=36\"\u003eUva 100- The 3n+1 problem\u003c/a\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ef(n) = 3n+1 , n為奇數 – (1)\n\n     = n/2 , n為偶數  – (2)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e簡而言之，題目會input兩個數字(a, b)，藉由f(n)的運算，請你輸出依照input順序輸出a b，\u003c/p\u003e","title":"Uva 100 - The 3n + 1 Problem"},{"content":"題目連結: Uva10633\n解題想法 N, M\n其中M為N除去最小位數\n用數學式表達即 M = ( N - (N%10) ) / 10\n題目Input: N-M\n希望Output:所有可能的N\n首先從數學式著手 M = ( N - (N%10) ) / 10\n題目給的Input: N-M = N - ( N - (N%10) ) / 10\n所以 10(N-M) = 9N + (N%10)\n又N%10的可能解為0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n(10k, 10k+1, 10k+2, ……, 10k+9)\n到此題目就變得十分簡單明瞭了 跟名稱Easy一樣(重點誤)\n開個for迴圈 宣告i 從0 ~ 10\n首先檢查 10*(N-M) - (N%10) 是否被 9 整除\nif整除 則計算N的值 並將他輸出\n題目測資可能會有10^16次方大 記得用long long儲存\nC++程式碼 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { long long int k, n; while(cin \u0026gt;\u0026gt; k \u0026amp;\u0026amp; k != 0){ for(int i = 9; i \u0026gt;= 0; i--) { if((10*k-i)%9 == 0){ //先判斷是否整除 而非先直接除再判斷是否為整數 n = (10*k-i)/9.0; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; endl; } return 0; } ","permalink":"https://flyotlin.github.io/posts/uva-10633---rare-easy-problem/","summary":"\u003cp\u003e題目連結: \u003ca href=\"https://onlinejudge.org/index.php?option=onlinejudge\u0026amp;page=show_problem\u0026amp;problem=1574\"\u003eUva10633\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"解題想法\"\u003e解題想法\u003c/h2\u003e\n\u003cp\u003eN, M\u003c/p\u003e\n\u003cp\u003e其中M為N除去最小位數\u003c/p\u003e\n\u003cp\u003e用數學式表達即 M = ( N - (N%10) ) / 10\u003c/p\u003e\n\u003cp\u003e題目Input: N-M\u003c/p\u003e\n\u003cp\u003e希望Output:所有可能的N\u003c/p\u003e\n\u003cp\u003e首先從數學式著手 M = ( N - (N%10) ) / 10\u003c/p\u003e","title":"Uva 10633 - Rare Easy Problem"},{"content":"I am flyotlin, you can call me Nick also, a graduate student in NYCU CS now.\nLove coding, loving things, and helping other people.\nI\u0026rsquo;m now interested in Software Engineering, Software Testing, DevOps, and Distributed System.\nExperienced in Linux, C/C++, Python, JavaScript (Vue, Node.js), Golang, SQL, Docker, Unit test, CI/CD, Ansible.\nMy GitHub: https://github.com/flyotlin\nMy LinkedIn: https://www.linkedin.com/in/flyotlin\nMy Email: flyotlin@gmail.com\nPS., Learning Functional Programming (Haskell) now.\n","permalink":"https://flyotlin.github.io/about/","summary":"\u003cp\u003eI am flyotlin, you can call me Nick also, a graduate student in \u003ca href=\"https://cs.nycu.edu.tw/\"\u003eNYCU CS\u003c/a\u003e now.\u003c/p\u003e\n\u003cp\u003eLove coding, loving things, and helping other people.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m now interested in Software Engineering, Software Testing, DevOps, and Distributed System.\u003c/p\u003e\n\u003cp\u003eExperienced in Linux, C/C++, Python, JavaScript (Vue, Node.js), Golang, SQL, Docker, Unit test, CI/CD, Ansible.\u003c/p\u003e\n\u003cp\u003eMy GitHub: \u003ca href=\"https://github.com/flyotlin\"\u003ehttps://github.com/flyotlin\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMy LinkedIn: \u003ca href=\"https://www.linkedin.com/in/flyotlin\"\u003ehttps://www.linkedin.com/in/flyotlin\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMy Email: \u003ca href=\"mailto:flyotlin@gmail.com\"\u003eflyotlin@gmail.com\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ePS., Learning Functional Programming (Haskell) now.\u003c/p\u003e","title":"About Me"},{"content":"","permalink":"https://flyotlin.github.io/categories/","summary":"categories","title":"Categories"},{"content":"Experiences NCUFresh 20 NCUFresh 21 NCU 創新教學網站 NCPC 2021 Honorable Mention 2021 ICPC Asia Taipei Bronze Medal Software Engineer in Test (Intern) at Synology Projects BadmintonCourtAgent UML-Editor AutoDanmuGen Along with web UI visualization Solar System Orbit Simulation ","permalink":"https://flyotlin.github.io/cv/","summary":"cv","title":"CV"}]